{"/home/travis/build/npmtest/node-npmtest-ldapjs/test.js":"/* istanbul instrument in package npmtest_ldapjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ldapjs/lib.npmtest_ldapjs.js":"/* istanbul instrument in package npmtest_ldapjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ldapjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ldapjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ldapjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ldapjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ldapjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ldapjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ldapjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ldapjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ldapjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ldapjs.__dirname + '/lib.npmtest_ldapjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/index.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar Logger = require('bunyan');\n\nvar client = require('./client');\nvar Attribute = require('./attribute');\nvar Change = require('./change');\nvar Protocol = require('./protocol');\nvar Server = require('./server');\n\nvar assert = require('assert');\nvar controls = require('./controls');\nvar persistentSearch = require('./persistent_search');\nvar dn = require('./dn');\nvar errors = require('./errors');\nvar filters = require('./filters');\nvar messages = require('./messages');\nvar url = require('./url');\n\n\n///--- API\n\nmodule.exports = {\n  Client: client.Client,\n  createClient: client.createClient,\n\n  Server: Server,\n  createServer: function (options) {\n    if (options === undefined)\n      options = {};\n\n    if (typeof (options) !== 'object')\n      throw new TypeError('options (object) required');\n\n    if (!options.log) {\n      options.log = new Logger({\n        name: 'ldapjs',\n        component: 'client',\n        stream: process.stderr\n      });\n    }\n\n    return new Server(options);\n  },\n\n  Attribute: Attribute,\n  Change: Change,\n\n  dn: dn,\n  DN: dn.DN,\n  RDN: dn.RDN,\n  parseDN: dn.parse,\n\n  persistentSearch: persistentSearch,\n  PersistentSearchCache: persistentSearch.PersistentSearchCache,\n\n  filters: filters,\n  parseFilter: filters.parseString,\n\n  url: url,\n  parseURL: url.parse\n};\n\n\n///--- Export all the childrenz\n\nvar k;\n\nfor (k in Protocol) {\n  if (Protocol.hasOwnProperty(k))\n    module.exports[k] = Protocol[k];\n}\n\nfor (k in messages) {\n  if (messages.hasOwnProperty(k))\n    module.exports[k] = messages[k];\n}\n\nfor (k in controls) {\n  if (controls.hasOwnProperty(k))\n    module.exports[k] = controls[k];\n}\n\nfor (k in filters) {\n  if (filters.hasOwnProperty(k)) {\n    if (k !== 'parse' && k !== 'parseString')\n      module.exports[k] = filters[k];\n  }\n}\n\nfor (k in errors) {\n  if (errors.hasOwnProperty(k)) {\n    module.exports[k] = errors[k];\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/client/index.js":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\n\nvar Logger = require('bunyan');\n\nvar Client = require('./client');\n\n\n///--- Globals\n\nvar DEF_LOG = new Logger({\n  name: 'ldapjs',\n  component: 'client',\n  stream: process.stderr,\n  serializers: Logger.stdSerializers\n});\n\n\n///--- Functions\n\nfunction xor() {\n  var b = false;\n  for (var i = 0; i < arguments.length; i++) {\n    if (arguments[i] && !b) {\n      b = true;\n    } else if (arguments[i] && b) {\n      return false;\n    }\n  }\n  return b;\n}\n\n\n\n///--- Exports\n\nmodule.exports = {\n  Client: Client,\n  createClient: function createClient(options) {\n    if (typeof (options) !== 'object')\n      throw new TypeError('options (object) required');\n    if (options.url && typeof (options.url) !== 'string')\n      throw new TypeError('options.url (string) required');\n    if (options.socketPath && typeof (options.socketPath) !== 'string')\n      throw new TypeError('options.socketPath must be a string');\n    if (!xor(options.url, options.socketPath))\n      throw new TypeError('options.url ^ options.socketPath (String) required');\n    if (!options.log)\n      options.log = DEF_LOG;\n    if (typeof (options.log) !== 'object')\n      throw new TypeError('options.log must be an object');\n\n    return new Client(options);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/client/client.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar EventEmitter = require('events').EventEmitter;\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\n\nvar once = require('once');\nvar backoff = require('backoff');\nvar vasync = require('vasync');\nvar assert = require('assert-plus');\nvar VError = require('verror').VError;\n\nvar Attribute = require('../attribute');\nvar Change = require('../change');\nvar Control = require('../controls/index').Control;\nvar SearchPager = require('./search_pager');\nvar Protocol = require('../protocol');\nvar dn = require('../dn');\nvar errors = require('../errors');\nvar filters = require('../filters');\nvar messages = require('../messages');\nvar url = require('../url');\n\n\n\n///--- Globals\n\nvar AbandonRequest = messages.AbandonRequest;\nvar AddRequest = messages.AddRequest;\nvar BindRequest = messages.BindRequest;\nvar CompareRequest = messages.CompareRequest;\nvar DeleteRequest = messages.DeleteRequest;\nvar ExtendedRequest = messages.ExtendedRequest;\nvar ModifyRequest = messages.ModifyRequest;\nvar ModifyDNRequest = messages.ModifyDNRequest;\nvar SearchRequest = messages.SearchRequest;\nvar UnbindRequest = messages.UnbindRequest;\nvar UnbindResponse = messages.UnbindResponse;\n\nvar LDAPResult = messages.LDAPResult;\nvar SearchEntry = messages.SearchEntry;\nvar SearchReference = messages.SearchReference;\nvar SearchResponse = messages.SearchResponse;\nvar Parser = messages.Parser;\n\nvar PresenceFilter = filters.PresenceFilter;\n\nvar ConnectionError = errors.ConnectionError;\n\nvar CMP_EXPECT = [errors.LDAP_COMPARE_TRUE, errors.LDAP_COMPARE_FALSE];\nvar MAX_MSGID = Math.pow(2, 31) - 1;\n\n// node 0.6 got rid of FDs, so make up a client id for logging\nvar CLIENT_ID = 0;\n\n\n\n///--- Internal Helpers\n\nfunction nextClientId() {\n  if (++CLIENT_ID === MAX_MSGID)\n    return 1;\n\n  return CLIENT_ID;\n}\n\nfunction validateControls(controls) {\n  if (Array.isArray(controls)) {\n    controls.forEach(function (c) {\n      if (!(c instanceof Control))\n        throw new TypeError('controls must be [Control]');\n    });\n  } else if (controls instanceof Control) {\n    controls = [controls];\n  } else {\n    throw new TypeError('controls must be [Control]');\n  }\n\n  return controls;\n}\n\nfunction ensureDN(input, strict) {\n  if (dn.DN.isDN(input)) {\n    return dn;\n  } else if (strict) {\n    return dn.parse(input);\n  } else if (typeof (input) === 'string') {\n    return input;\n  } else {\n    throw new Error('invalid DN');\n  }\n}\n\n/**\n * Queue to contain LDAP requests.\n *\n * @param {Object} opts queue options\n *\n * Accepted Options:\n * - size: Maximum queue size\n * - timeout: Set timeout between first queue insertion and queue flush.\n */\nfunction RequestQueue(opts) {\n  if (!opts || typeof (opts) !== 'object') {\n    opts = {};\n  }\n  this.size = (opts.size > 0) ? opts.size : Infinity;\n  this.timeout = (opts.timeout > 0) ? opts.timeout : 0;\n  this._queue = [];\n  this._timer = null;\n  this._frozen = false;\n}\n\n/**\n * Insert request into queue.\n *\n */\nRequestQueue.prototype.enqueue = function enqueue(msg, expect, emitter, cb) {\n  if (this._queue.length >= this.size || this._frozen) {\n    return false;\n  }\n  var self = this;\n  this._queue.push([msg, expect, emitter, cb]);\n  if (this.timeout > 0) {\n    if (this._timer !== null) {\n      this._timer = setTimeout(function () {\n          // If queue times out, don't allow new entries until thawed\n          self.freeze();\n          self.purge();\n      }, this.timeout);\n    }\n  }\n  return true;\n};\n\n/**\n * Process all queued requests with callback.\n */\nRequestQueue.prototype.flush = function flush(cb) {\n  if (this._timer) {\n    clearTimeout(this._timer);\n    this._timer = null;\n  }\n  var items = this._queue;\n  this._queue = [];\n  items.forEach(function (req) {\n    cb(req[0], req[1], req[2], req[3]);\n  });\n};\n\n/**\n * Purge all queued requests with an error.\n */\nRequestQueue.prototype.purge = function purge() {\n  this.flush(function (msg, expect, emitter, cb) {\n    cb(new errors.TimeoutError('request queue timeout'));\n  });\n};\n\n/**\n * Freeze queue, refusing any new entries.\n */\nRequestQueue.prototype.freeze = function freeze() {\n  this._frozen = true;\n};\n\n/**\n * Thaw queue, allowing new entries again.\n */\nRequestQueue.prototype.thaw = function thaw() {\n  this._frozen = false;\n};\n\n\n/**\n * Track message callback by messageID.\n */\nfunction MessageTracker(opts) {\n  assert.object(opts);\n  assert.string(opts.id);\n  assert.object(opts.parser);\n\n  this.id = opts.id;\n  this._msgid = 0;\n  this._messages = {};\n  this._abandoned = {};\n  this.parser = opts.parser;\n\n  var self = this;\n  this.__defineGetter__('pending', function () {\n    return Object.keys(self._messages);\n  });\n}\n\n/**\n * Record a messageID and callback.\n */\nMessageTracker.prototype.track = function track(message, callback) {\n  var msgid = this._nextID();\n  message.messageID = msgid;\n  this._messages[msgid] = callback;\n  return msgid;\n};\n\n/**\n * Fetch callback based on messageID.\n */\nMessageTracker.prototype.fetch = function fetch(msgid) {\n  var msg = this._messages[msgid];\n  if (msg) {\n    this._purgeAbandoned(msgid);\n    return msg;\n  }\n  // It's possible that the server has not received the abandon request yet.\n  // While waiting for evidence that the abandon has been received, incoming\n  // messages that match the abandoned msgid will be handled as normal.\n  msg = this._abandoned[msgid];\n  if (msg) {\n    return msg.cb;\n  }\n  return null;\n};\n\n/**\n * Cease tracking for a given messageID.\n */\nMessageTracker.prototype.remove = function remove(msgid) {\n  if (this._messages[msgid]) {\n    delete this._messages[msgid];\n  } else if (this._abandoned[msgid]) {\n    delete this._abandoned[msgid];\n  }\n};\n\n/**\n * Mark a messageID as abandoned.\n */\nMessageTracker.prototype.abandon = function abandonMsg(msgid) {\n  if (this._messages[msgid]) {\n    // Keep track of \"when\" the message was abandoned\n    this._abandoned[msgid] = {\n      age: this._msgid,\n      cb: this._messages[msgid]\n    };\n    delete this._messages[msgid];\n  }\n};\n\n/**\n * Purge old items from abandoned list.\n */\nMessageTracker.prototype._purgeAbandoned = function _purgeAbandoned(msgid) {\n  var self = this;\n  // Is (comp >= ref) according to sliding window\n  function geWindow(ref, comp) {\n    var max = ref + (MAX_MSGID/2);\n    var min = ref;\n    if (max >= MAX_MSGID) {\n      // Handle roll-over\n      max = max - MAX_MSGID - 1;\n      return ((comp <= max) || (comp >= min));\n    } else {\n      return ((comp <= max) && (comp >= min));\n    }\n  }\n\n  Object.keys(this._abandoned).forEach(function (id) {\n    // Abandoned messageIDs can be forgotten if a received messageID is \"newer\"\n    if (geWindow(self._abandoned[id].age, msgid)) {\n      self._abandoned[id].cb(new errors.AbandonedError(\n        'client request abandoned'));\n      delete self._abandoned[id];\n    }\n  });\n};\n\n/**\n * Allocate the next messageID according to a sliding window.\n */\nMessageTracker.prototype._nextID = function _nextID() {\n  if (++this._msgid >= MAX_MSGID)\n    this._msgid = 1;\n\n  return this._msgid;\n};\n\n///--- API\n\n/**\n * Constructs a new client.\n *\n * The options object is required, and must contain either a URL (string) or\n * a socketPath (string); the socketPath is only if you want to talk to an LDAP\n * server over a Unix Domain Socket.  Additionally, you can pass in a bunyan\n * option that is the result of `new Logger()`, presumably after you've\n * configured it.\n *\n * @param {Object} options must have either url or socketPath.\n * @throws {TypeError} on bad input.\n */\nfunction Client(options) {\n  assert.ok(options);\n\n  EventEmitter.call(this, options);\n\n  var self = this;\n  var _url;\n  if (options.url)\n    _url = url.parse(options.url);\n  this.host = _url ? _url.hostname : undefined;\n  this.port = _url ? _url.port : false;\n  this.secure = _url ? _url.secure : false;\n  this.url = _url;\n  this.tlsOptions = options.tlsOptions;\n  this.socketPath = options.socketPath || false;\n\n  this.log = options.log.child({clazz: 'Client'}, true);\n\n  this.timeout = parseInt((options.timeout || 0), 10);\n  this.connectTimeout = parseInt((options.connectTimeout || 0), 10);\n  this.idleTimeout = parseInt((options.idleTimeout || 0), 10);\n  if (options.reconnect) {\n    // Fall back to defaults if options.reconnect === true\n    var rOpts = (typeof (options.reconnect) === 'object') ?\n      options.reconnect : {};\n    this.reconnect = {\n      initialDelay: parseInt(rOpts.initialDelay || 100, 10),\n      maxDelay: parseInt(rOpts.maxDelay || 10000, 10),\n      failAfter: parseInt(rOpts.failAfter, 10) || Infinity\n    };\n  }\n  this.strictDN = (options.strictDN !== undefined) ? options.strictDN : true;\n\n  this.queue = new RequestQueue({\n    size: parseInt((options.queueSize || 0), 10),\n    timeout: parseInt((options.queueTimeout || 0), 10)\n  });\n  if (options.queueDisable) {\n    this.queue.freeze();\n  }\n\n  // Implicitly configure setup action to bind the client if bindDN and\n  // bindCredentials are passed in.  This will more closely mimic PooledClient\n  // auto-login behavior.\n  if (options.bindDN !== undefined &&\n      options.bindCredentials !== undefined) {\n    this.on('setup', function (clt, cb) {\n      clt.bind(options.bindDN, options.bindCredentials, function (err) {\n        if (err) {\n          self.emit('error', err);\n        }\n        cb(err);\n      });\n    });\n  }\n\n  this._socket = null;\n  this.connected = false;\n  this.connect();\n}\nutil.inherits(Client, EventEmitter);\nmodule.exports = Client;\n\n\n/**\n * Sends an abandon request to the LDAP server.\n *\n * The callback will be invoked as soon as the data is flushed out to the\n * network, as there is never a response from abandon.\n *\n * @param {Number} messageID the messageID to abandon.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.abandon = function abandon(messageID, controls, callback) {\n  assert.number(messageID, 'messageID');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  var req = new AbandonRequest({\n    abandonID: messageID,\n    controls: controls\n  });\n\n  return this._send(req, 'abandon', null, callback);\n};\n\n\n/**\n * Adds an entry to the LDAP server.\n *\n * Entry can be either [Attribute] or a plain JS object where the\n * values are either a plain value or an array of values.  Any value (that's\n * not an array) will get converted to a string, so keep that in mind.\n *\n * @param {String} name the DN of the entry to add.\n * @param {Object} entry an array of Attributes to be added or a JS object.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.add = function add(name, entry, controls, callback) {\n  assert.ok(name !== undefined, 'name');\n  assert.object(entry, 'entry');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  if (Array.isArray(entry)) {\n    entry.forEach(function (a) {\n      if (!Attribute.isAttribute(a))\n        throw new TypeError('entry must be an Array of Attributes');\n    });\n  } else {\n    var save = entry;\n\n    entry = [];\n    Object.keys(save).forEach(function (k) {\n      var attr = new Attribute({type: k});\n      if (Array.isArray(save[k])) {\n        save[k].forEach(function (v) {\n          attr.addValue(v.toString());\n        });\n      } else {\n        attr.addValue(save[k].toString());\n      }\n      entry.push(attr);\n    });\n  }\n\n  var req = new AddRequest({\n    entry: ensureDN(name, this.strictDN),\n    attributes: entry,\n    controls: controls\n  });\n\n  return this._send(req, [errors.LDAP_SUCCESS], null, callback);\n};\n\n\n/**\n * Performs a simple authentication against the server.\n *\n * @param {String} name the DN to bind as.\n * @param {String} credentials the userPassword associated with name.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.bind = function bind(name,\n                                      credentials,\n                                      controls,\n                                      callback,\n                                      _bypass) {\n  if (typeof (name) !== 'string' && !(name instanceof dn.DN))\n    throw new TypeError('name (string) required');\n  assert.optionalString(credentials, 'credentials');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  var req = new BindRequest({\n    name: name || '',\n    authentication: 'Simple',\n    credentials: credentials || '',\n    controls: controls\n  });\n\n  return this._send(req, [errors.LDAP_SUCCESS], null, callback, _bypass);\n};\n\n\n/**\n * Compares an attribute/value pair with an entry on the LDAP server.\n *\n * @param {String} name the DN of the entry to compare attributes with.\n * @param {String} attr name of an attribute to check.\n * @param {String} value value of an attribute to check.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, boolean, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.compare = function compare(name,\n                                            attr,\n                                            value,\n                                            controls,\n                                            callback) {\n  assert.ok(name !== undefined, 'name');\n  assert.string(attr, 'attr');\n  assert.string(value, 'value');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  var req = new CompareRequest({\n    entry: ensureDN(name, this.strictDN),\n    attribute: attr,\n    value: value,\n    controls: controls\n  });\n\n  return this._send(req, CMP_EXPECT, null, function (err, res) {\n    if (err)\n      return callback(err);\n\n    return callback(null, (res.status === errors.LDAP_COMPARE_TRUE), res);\n  });\n};\n\n\n/**\n * Deletes an entry from the LDAP server.\n *\n * @param {String} name the DN of the entry to delete.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.del = function del(name, controls, callback) {\n  assert.ok(name !== undefined, 'name');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  var req = new DeleteRequest({\n    entry: ensureDN(name, this.strictDN),\n    controls: controls\n  });\n\n  return this._send(req, [errors.LDAP_SUCCESS], null, callback);\n};\n\n\n/**\n * Performs an extended operation on the LDAP server.\n *\n * Pretty much none of the LDAP extended operations return an OID\n * (responseName), so I just don't bother giving it back in the callback.\n * It's on the third param in `res` if you need it.\n *\n * @param {String} name the OID of the extended operation to perform.\n * @param {String} value value to pass in for this operation.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, value, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.exop = function exop(name, value, controls, callback) {\n  assert.string(name, 'name');\n  if (typeof (value) === 'function') {\n    callback = value;\n    controls = [];\n    value = '';\n  }\n  if (!(Buffer.isBuffer(value) || typeof (value) === 'string'))\n    throw new TypeError('value (Buffer || string) required');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  var req = new ExtendedRequest({\n    requestName: name,\n    requestValue: value,\n    controls: controls\n  });\n\n  return this._send(req, [errors.LDAP_SUCCESS], null, function (err, res) {\n    if (err)\n      return callback(err);\n\n    return callback(null, res.responseValue || '', res);\n  });\n};\n\n\n/**\n * Performs an LDAP modify against the server.\n *\n * @param {String} name the DN of the entry to modify.\n * @param {Change} change update to perform (can be [Change]).\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.modify = function modify(name, change, controls, callback) {\n  assert.ok(name !== undefined, 'name');\n  assert.object(change, 'change');\n\n  var changes = [];\n\n  function changeFromObject(change) {\n    if (!change.operation && !change.type)\n      throw new Error('change.operation required');\n    if (typeof (change.modification) !== 'object')\n      throw new Error('change.modification (object) required');\n\n    if (Object.keys(change.modification).length == 2 &&\n        typeof (change.modification.type) === 'string' &&\n        Array.isArray(change.modification.vals)) {\n      // Use modification directly if it's already normalized:\n      changes.push(new Change({\n        operation: change.operation || change.type,\n        modification: change.modification\n      }));\n    } else {\n      // Normalize the modification object\n      Object.keys(change.modification).forEach(function (k) {\n        var mod = {};\n        mod[k] = change.modification[k];\n        changes.push(new Change({\n          operation: change.operation || change.type,\n          modification: mod\n        }));\n      });\n    }\n  }\n\n  if (Change.isChange(change)) {\n    changes.push(change);\n  } else if (Array.isArray(change)) {\n    change.forEach(function (c) {\n      if (Change.isChange(c)) {\n        changes.push(c);\n      } else {\n        changeFromObject(c);\n      }\n    });\n  } else {\n    changeFromObject(change);\n  }\n\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  var req = new ModifyRequest({\n    object: ensureDN(name, this.strictDN),\n    changes: changes,\n    controls: controls\n  });\n\n  return this._send(req, [errors.LDAP_SUCCESS], null, callback);\n};\n\n\n/**\n * Performs an LDAP modifyDN against the server.\n *\n * This does not allow you to keep the old DN, as while the LDAP protocol\n * has a facility for that, it's stupid. Just Search/Add.\n *\n * This will automatically deal with \"new superior\" logic.\n *\n * @param {String} name the DN of the entry to modify.\n * @param {String} newName the new DN to move this entry to.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.modifyDN = function modifyDN(name,\n                                              newName,\n                                              controls,\n                                              callback) {\n  assert.ok(name !== undefined, 'name');\n  assert.string(newName, 'newName');\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback);\n\n  var DN = ensureDN(name);\n  // TODO: is non-strict handling desired here?\n  var newDN = dn.parse(newName);\n\n  var req = new ModifyDNRequest({\n    entry: DN,\n    deleteOldRdn: true,\n    controls: controls\n  });\n\n  if (newDN.length !== 1) {\n    req.newRdn = dn.parse(newDN.rdns.shift().toString());\n    req.newSuperior = newDN;\n  } else {\n    req.newRdn = newDN;\n  }\n\n  return this._send(req, [errors.LDAP_SUCCESS], null, callback);\n};\n\n\n/**\n * Performs an LDAP search against the server.\n *\n * Note that the defaults for options are a 'base' search, if that's what\n * you want you can just pass in a string for options and it will be treated\n * as the search filter.  Also, you can either pass in programatic Filter\n * objects or a filter string as the filter option.\n *\n * Note that this method is 'special' in that the callback 'res' param will\n * have two important events on it, namely 'entry' and 'end' that you can hook\n * to.  The former will emit a SearchEntry object for each record that comes\n * back, and the latter will emit a normal LDAPResult object.\n *\n * @param {String} base the DN in the tree to start searching at.\n * @param {Object} options parameters:\n *                           - {String} scope default of 'base'.\n *                           - {String} filter default of '(objectclass=*)'.\n *                           - {Array} attributes [string] to return.\n *                           - {Boolean} attrsOnly whether to return values.\n * @param {Control} controls (optional) either a Control or [Control].\n * @param {Function} callback of the form f(err, res).\n * @throws {TypeError} on invalid input.\n */\nClient.prototype.search = function search(base,\n                                          options,\n                                          controls,\n                                          callback,\n                                          _bypass) {\n  assert.ok(base !== undefined, 'search base');\n  if (Array.isArray(options) || (options instanceof Control)) {\n    controls = options;\n    options = {};\n  } else if (typeof (options) === 'function') {\n    callback = options;\n    controls = [];\n    options = {\n      filter: new PresenceFilter({attribute: 'objectclass'})\n    };\n  } else if (typeof (options) === 'string') {\n    options = {filter: filters.parseString(options)};\n  } else if (typeof (options) !== 'object') {\n    throw new TypeError('options (object) required');\n  }\n  if (typeof (options.filter) === 'string') {\n    options.filter = filters.parseString(options.filter);\n  } else if (!options.filter) {\n    options.filter = new PresenceFilter({attribute: 'objectclass'});\n  } else if (!filters.isFilter(options.filter)) {\n    throw new TypeError('options.filter (Filter) required');\n  }\n  if (typeof (controls) === 'function') {\n    callback = controls;\n    controls = [];\n  } else {\n    controls = validateControls(controls);\n  }\n  assert.func(callback, 'callback');\n\n  if (options.attributes) {\n    if (!Array.isArray(options.attributes)) {\n      if (typeof (options.attributes) === 'string') {\n        options.attributes = [options.attributes];\n      } else {\n        throw new TypeError('options.attributes must be an Array of Strings');\n      }\n    }\n  }\n\n  var self = this;\n  var baseDN = ensureDN(base, this.strictDN);\n\n  function sendRequest(ctrls, emitter, cb) {\n    var req = new SearchRequest({\n      baseObject: baseDN,\n      scope: options.scope || 'base',\n      filter: options.filter,\n      derefAliases: options.derefAliases || Protocol.NEVER_DEREF_ALIASES,\n      sizeLimit: options.sizeLimit || 0,\n      timeLimit: options.timeLimit || 10,\n      typesOnly: options.typesOnly || false,\n      attributes: options.attributes || [],\n      controls: ctrls\n    });\n\n    return self._send(req,\n        [errors.LDAP_SUCCESS],\n        emitter,\n        cb,\n        _bypass);\n  }\n\n  if (options.paged) {\n    // Perform automated search paging\n    var pageOpts = typeof (options.paged) === 'object' ? options.paged : {};\n    var size = 100; // Default page size\n    if (pageOpts.pageSize > 0) {\n      size = pageOpts.pageSize;\n    } else if (options.sizeLimit > 1)  {\n      // According to the RFC, servers should ignore the paging control if\n      // pageSize >= sizelimit.  Some might still send results, but it's safer\n      // to stay under that figure when assigning a default value.\n      size = options.sizeLimit - 1;\n    }\n\n    var pager = new SearchPager({\n      callback: callback,\n      controls: controls,\n      pageSize: size,\n      pagePause: pageOpts.pagePause\n    });\n    pager.on('search', sendRequest);\n    pager.begin();\n  } else {\n    sendRequest(controls, new EventEmitter(), callback);\n  }\n};\n\n\n/**\n * Unbinds this client from the LDAP server.\n *\n * Note that unbind does not have a response, so this callback is actually\n * optional; either way, the client is disconnected.\n *\n * @param {Function} callback of the form f(err).\n * @throws {TypeError} if you pass in callback as not a function.\n */\nClient.prototype.unbind = function unbind(callback) {\n  if (!callback)\n    callback = function () {};\n\n  if (typeof (callback) !== 'function')\n    throw new TypeError('callback must be a function');\n\n  // When the socket closes, it is useful to know whether it was due to a\n  // user-initiated unbind or something else.\n  this.unbound = true;\n\n  if (!this._socket)\n    return callback();\n\n  var req = new UnbindRequest();\n  return this._send(req, 'unbind', null, callback);\n};\n\n\n/**\n * Attempt to secure connection with StartTLS.\n */\nClient.prototype.starttls = function starttls(options,\n                                              controls,\n                                              callback,\n                                              _bypass) {\n  assert.optionalObject(options);\n  options = options || {};\n  callback = once(callback);\n  var self = this;\n\n  if (this._starttls) {\n    return callback(new Error('STARTTLS already in progress or active'));\n  }\n\n  function onSend(err, emitter) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    /*\n     * Now that the request has been sent, block all outgoing messages\n     * until an error is received or we successfully complete the setup.\n     */\n    // TODO: block traffic\n    self._starttls = {\n      started: true\n    };\n\n    emitter.on('error', function (err) {\n      self._starttls = null;\n      callback(err);\n    });\n    emitter.on('end', function (res) {\n      var sock = self._socket;\n      /*\n       * Unplumb socket data during SSL negotiation.\n       * This will prevent the LDAP parser from stumbling over the TLS\n       * handshake and raising a ruckus.\n       */\n      sock.removeAllListeners('data');\n\n      options.socket = sock;\n      var secure = tls.connect(options);\n      secure.once('secureConnect', function () {\n        /*\n         * Wire up 'data' and 'error' handlers like the normal socket.\n         * Handling 'end' events isn't necessary since the underlying socket\n         * will handle those.\n         */\n        secure.removeAllListeners('error');\n        secure.on('data', function onData(data) {\n          if (self.log.trace())\n            self.log.trace('data event: %s', util.inspect(data));\n\n          self._tracker.parser.write(data);\n        });\n        secure.on('error', function (err)  {\n          if (self.log.trace())\n            self.log.trace({err: err}, 'error event: %s', new Error().stack);\n\n          self.emit('error', err);\n          sock.destroy();\n        });\n        callback(null);\n      });\n      secure.once('error', function (err) {\n        // If the SSL negotiation failed, to back to plain mode.\n        self._starttls = null;\n        secure.removeAllListeners();\n        callback(err);\n      });\n      self._starttls.success = true;\n      self._socket = secure;\n    });\n  }\n\n  var req = new ExtendedRequest({\n    requestName: '1.3.6.1.4.1.1466.20037',\n    requestValue: null,\n    controls: controls\n  });\n\n  return this._send(req,\n      [errors.LDAP_SUCCESS],\n      new EventEmitter(),\n      onSend,\n      _bypass);\n};\n\n\n/**\n * Disconnect from the LDAP server and do not allow reconnection.\n *\n * If the client is instantiated with proper reconnection options, it's\n * possible to initiate new requests after a call to unbind since the client\n * will attempt to reconnect in order to fulfill the request.\n *\n * Calling destroy will prevent any further reconnection from occurring.\n *\n * @param {Object} err (Optional) error that was cause of client destruction\n */\nClient.prototype.destroy = function destroy(err) {\n  this.destroyed = true;\n  this.queue.freeze();\n  // Purge any queued requests which are now meaningless\n  this.queue.flush(function (msg, expect, emitter, cb) {\n    if (typeof (cb) === 'function') {\n      cb(new Error('client destroyed'));\n      }\n  });\n  if (this.connected) {\n    this.unbind();\n  } else if (this._socket) {\n    this._socket.destroy();\n  }\n  this.emit('destroy', err);\n};\n\n\n/**\n * Initiate LDAP connection.\n */\nClient.prototype.connect = function connect() {\n  if (this.connecting || this.connected) {\n    return;\n  }\n  var self = this;\n  var log = this.log;\n  var socket;\n  var tracker;\n\n  // Establish basic socket connection\n  function connectSocket(cb) {\n    cb = once(cb);\n\n    function onResult(err, res) {\n      if (err) {\n        if (self.connectTimer) {\n          clearTimeout(self.connectTimer);\n          self.connectTimer = null;\n        }\n        self.emit('connectError', err);\n      }\n      cb(err, res);\n    }\n    function onConnect() {\n      if (self.connectTimer) {\n        clearTimeout(self.connectTimer);\n        self.connectTimer = null;\n      }\n      socket.removeAllListeners('error')\n        .removeAllListeners('connect')\n        .removeAllListeners('secureConnect');\n\n      tracker.id = nextClientId() + '__' + tracker.id;\n      self.log = self.log.child({ldap_id: tracker.id}, true);\n\n      // Move on to client setup\n      setupClient(cb);\n    }\n\n    var port = (self.port || self.socketPath);\n    if (self.secure) {\n      socket = tls.connect(port, self.host, self.tlsOptions);\n      socket.once('secureConnect', onConnect);\n    } else {\n      socket = net.connect(port, self.host);\n      socket.once('connect', onConnect);\n    }\n    socket.once('error', onResult);\n    initSocket();\n\n    // Setup connection timeout handling, if desired\n    if (self.connectTimeout) {\n      self.connectTimer = setTimeout(function onConnectTimeout() {\n        if (!socket || !socket.readable || !socket.writeable) {\n          socket.destroy();\n          self._socket = null;\n          onResult(new ConnectionError('connection timeout'));\n        }\n      }, self.connectTimeout);\n    }\n  }\n\n  // Initialize socket events and LDAP parser.\n  function initSocket() {\n    tracker = new MessageTracker({\n      id: self.url ? self.url.href : self.socketPath,\n      parser: new Parser({log: log})\n    });\n\n    // This won't be set on TLS. So. Very. Annoying.\n    if (typeof (socket.setKeepAlive) !== 'function') {\n      socket.setKeepAlive = function setKeepAlive(enable, delay) {\n        return socket.socket ?\n          socket.socket.setKeepAlive(enable, delay) : false;\n      };\n    }\n\n    socket.on('data', function onData(data) {\n      if (log.trace())\n        log.trace('data event: %s', util.inspect(data));\n\n      tracker.parser.write(data);\n    });\n\n    // The \"router\"\n    tracker.parser.on('message', function onMessage(message) {\n      message.connection = self._socket;\n      var callback = tracker.fetch(message.messageID);\n\n      if (!callback) {\n        log.error({message: message.json}, 'unsolicited message');\n        return false;\n      }\n\n      return callback(message);\n    });\n\n    tracker.parser.on('error', function onParseError(err) {\n      self.emit('error', new VError(err, 'Parser error for %s',\n            tracker.id));\n      self.connected = false;\n      socket.end();\n    });\n  }\n\n  // After connect, register socket event handlers and run any setup actions\n  function setupClient(cb) {\n    cb = once(cb);\n\n    // Indicate failure if anything goes awry during setup\n    function bail(err) {\n      socket.destroy();\n      cb(err || new Error('client error during setup'));\n    }\n    // Work around lack of close event on tls.socket in node < 0.11\n    ((socket.socket) ? socket.socket : socket).once('close', bail);\n    socket.once('error', bail);\n    socket.once('end', bail);\n    socket.once('timeout', bail);\n\n    self._socket = socket;\n    self._tracker = tracker;\n\n    // Run any requested setup (such as automatically performing a bind) on\n    // socket before signalling successful connection.\n    // This setup needs to bypass the request queue since all other activity is\n    // blocked until the connection is considered fully established post-setup.\n    // Only allow bind/search/starttls for now.\n    var basicClient = {\n      bind: function bindBypass(name, credentials, controls, callback) {\n        return self.bind(name, credentials, controls, callback, true);\n      },\n      search: function searchBypass(base, options, controls, callback) {\n        return self.search(base, options, controls, callback, true);\n      },\n      starttls: function starttlsBypass(options, controls, callback) {\n        return self.starttls(options, controls, callback, true);\n      },\n      unbind: self.unbind.bind(self)\n    };\n    vasync.forEachPipeline({\n      func: function (f, callback) {\n        f(basicClient, callback);\n      },\n      inputs: self.listeners('setup')\n    }, function (err, res) {\n      if (err) {\n        self.emit('setupError', err);\n      }\n      cb(err);\n    });\n  }\n\n  // Wire up \"official\" event handlers after successful connect/setup\n  function postSetup() {\n    socket.removeAllListeners('error')\n      .removeAllListeners('close')\n      .removeAllListeners('end')\n      .removeAllListeners('timeout');\n\n    // Work around lack of close event on tls.socket in node < 0.11\n    ((socket.socket) ? socket.socket : socket).once('close',\n      self._onClose.bind(self));\n    socket.on('end', function onEnd() {\n      if (log.trace())\n        log.trace('end event');\n\n      self.emit('end');\n      socket.end();\n    });\n    socket.on('error', function onSocketError(err) {\n      if (log.trace())\n        log.trace({err: err}, 'error event: %s', new Error().stack);\n\n      self.emit('error', err);\n      socket.destroy();\n    });\n    socket.on('timeout', function onTimeout() {\n      if (log.trace())\n        log.trace('timeout event');\n\n      self.emit('socketTimeout');\n      socket.end();\n    });\n  }\n\n  var retry;\n  var failAfter;\n  if (this.reconnect) {\n    retry = backoff.exponential({\n      initialDelay: this.reconnect.initialDelay,\n      maxDelay: this.reconnect.maxDelay\n    });\n    failAfter = this.reconnect.failAfter;\n  } else {\n    retry = backoff.exponential({\n      initialDelay: 1,\n      maxDelay: 2\n    });\n    failAfter = 1;\n  }\n  retry.failAfter(failAfter);\n\n  retry.on('ready', function (num, delay) {\n    if (self.destroyed) {\n      // Cease connection attempts if destroyed\n      return;\n    }\n    connectSocket(function (err) {\n      if (!err) {\n        postSetup();\n        self.connecting = false;\n        self.connected = true;\n        self.emit('connect', socket);\n        self.log.debug('connected after %d attempt(s)', num+1);\n        // Flush any queued requests\n        self._flushQueue();\n        self._connectRetry = null;\n      } else {\n        retry.backoff(err);\n      }\n    });\n  });\n  retry.on('fail', function (err) {\n    if (self.destroyed) {\n      // Silence any connect/setup errors if destroyed\n      return;\n    }\n    self.log.debug('failed to connect after %d attempts', failAfter);\n    // Communicate the last-encountered error\n    if (err instanceof ConnectionError) {\n      self.emit('connectTimeout', err);\n    } else {\n      self.emit('error', err);\n    }\n  });\n\n  this._connectRetry = retry;\n  this.connecting = true;\n  retry.backoff();\n};\n\n\n\n///--- Private API\n\n/**\n * Flush queued requests out to the socket.\n */\nClient.prototype._flushQueue = function _flushQueue() {\n  // Pull items we're about to process out of the queue.\n  this.queue.flush(this._send.bind(this));\n};\n\n/**\n * Clean up socket/parser resources after socket close.\n */\nClient.prototype._onClose = function _onClose(had_err) {\n  var socket = this._socket;\n  var tracker = this._tracker;\n  socket.removeAllListeners('connect')\n    .removeAllListeners('data')\n    .removeAllListeners('drain')\n    .removeAllListeners('end')\n    .removeAllListeners('error')\n    .removeAllListeners('timeout');\n  this._socket = null;\n  this.connected = false;\n\n  ((socket.socket) ? socket.socket : socket).removeAllListeners('close');\n\n  if (this.log.trace())\n    this.log.trace('close event had_err=%s', had_err ? 'yes' : 'no');\n\n  this.emit('close', had_err);\n  // On close we have to walk the outstanding messages and go invoke their\n  // callback with an error.\n  tracker.pending.forEach(function (msgid) {\n    var cb = tracker.fetch(msgid);\n    tracker.remove(msgid);\n\n    if (socket.unbindMessageID !== parseInt(msgid, 10)) {\n      return cb(new ConnectionError(tracker.id + ' closed'));\n    } else {\n      // Unbinds will be communicated as a success since we're closed\n      var unbind = new UnbindResponse({messageID: msgid});\n      unbind.status = 'unbind';\n      return cb(unbind);\n    }\n  });\n\n  // Trash any parser or starttls state\n  this._tracker = null;\n  delete this._starttls;\n\n  // Automatically fire reconnect logic if the socket was closed for any reason\n  // other than a user-initiated unbind.\n  if (this.reconnect && !this.unbound) {\n    this.connect();\n  }\n  this.unbound = false;\n  return false;\n};\n\n/**\n * Maintain idle timer for client.\n *\n * Will start timer to fire 'idle' event if conditions are satisfied.  If\n * conditions are not met and a timer is running, it will be cleared.\n *\n * @param {Boolean} override explicitly disable timer.\n */\nClient.prototype._updateIdle = function _updateIdle(override) {\n  if (this.idleTimeout === 0) {\n    return;\n  }\n  // Client must be connected but not waiting on any request data\n  var self = this;\n  function isIdle(disable) {\n    return ((disable !== true) &&\n      (self._socket && self.connected) &&\n      (self._tracker.pending.length === 0));\n  }\n  if (isIdle(override)) {\n    if (!this._idleTimer) {\n      this._idleTimer = setTimeout(function () {\n        // Double-check idleness in case socket was torn down\n        if (isIdle()) {\n          self.emit('idle');\n        }\n      }, this.idleTimeout);\n    }\n  } else {\n    if (this._idleTimer) {\n      clearTimeout(this._idleTimer);\n      this._idleTimer = null;\n    }\n  }\n};\n\n/**\n * Attempt to send an LDAP request.\n */\nClient.prototype._send = function _send(message,\n                                        expect,\n                                        emitter,\n                                        callback,\n                                        _bypass) {\n  assert.ok(message);\n  assert.ok(expect);\n  assert.optionalObject(emitter);\n  assert.ok(callback);\n\n  // Allow connect setup traffic to bypass checks\n  if (_bypass && this._socket && this._socket.writable) {\n    return this._sendSocket(message, expect, emitter, callback);\n  }\n  if (!this._socket || !this.connected) {\n    if (!this.queue.enqueue(message, expect, emitter, callback)) {\n      callback(new ConnectionError('connection unavailable'));\n    }\n    // Initiate reconnect if needed\n    if (this.reconnect) {\n      this.connect();\n    }\n    return false;\n  } else {\n    this._flushQueue();\n    return this._sendSocket(message, expect, emitter, callback);\n  }\n};\n\nClient.prototype._sendSocket = function _sendSocket(message,\n                                                    expect,\n                                                    emitter,\n                                                    callback) {\n  var conn = this._socket;\n  var tracker = this._tracker;\n  var log = this.log;\n  var self = this;\n  var timer = false;\n  var sentEmitter = false;\n\n  function sendResult(event, obj) {\n    if (event === 'error' && self.listeners('resultError')) {\n      self.emit('resultError', obj);\n    }\n    if (emitter) {\n      if (event === 'error') {\n        // Error will go unhandled if emitter hasn't been sent via callback.\n        // Execute callback with the error instead.\n        if (!sentEmitter)\n          return callback(obj);\n      }\n      return emitter.emit(event, obj);\n    }\n\n    if (event === 'error')\n      return callback(obj);\n\n    return callback(null, obj);\n  }\n\n  function messageCallback(msg) {\n    if (timer)\n      clearTimeout(timer);\n\n    if (log.trace())\n      log.trace({msg: msg ? msg.json : null}, 'response received');\n\n    if (expect === 'abandon')\n      return sendResult('end', null);\n\n    if (msg instanceof SearchEntry || msg instanceof SearchReference) {\n      var event = msg.constructor.name;\n      event = event[0].toLowerCase() + event.slice(1);\n      return sendResult(event, msg);\n    } else {\n      tracker.remove(message.messageID);\n      // Potentially mark client as idle\n      self._updateIdle();\n\n      if (msg instanceof LDAPResult) {\n        if (expect.indexOf(msg.status) === -1) {\n          return sendResult('error', errors.getError(msg));\n        }\n        return sendResult('end', msg);\n      } else if (msg instanceof Error) {\n        return sendResult('error', msg);\n      } else {\n        return sendResult('error', new errors.ProtocolError(msg.type));\n      }\n    }\n  }\n\n  function onRequestTimeout() {\n    self.emit('timeout', message);\n    var cb = tracker.fetch(message.messageID);\n    if (cb) {\n      //FIXME: the timed-out request should be abandoned\n      cb(new errors.TimeoutError('request timeout (client interrupt)'));\n    }\n  }\n\n  function writeCallback() {\n    if (expect === 'abandon') {\n      // Mark the messageID specified as abandoned\n      tracker.abandon(message.abandonID);\n      // No need to track the abandon request itself\n      tracker.remove(message.id);\n      return callback(null);\n    } else if (expect === 'unbind') {\n      conn.unbindMessageID = message.id;\n      // Mark client as disconnected once unbind clears the socket\n      self.connected = false;\n      // Some servers will RST the connection after receiving an unbind.\n      // Socket errors are blackholed since the connection is being closed.\n      conn.removeAllListeners('error');\n      conn.on('error', function () {});\n      conn.end();\n    } else if (emitter) {\n      sentEmitter = true;\n      return callback(null, emitter);\n    }\n    return false;\n  }\n\n  // Start actually doing something...\n  tracker.track(message, messageCallback);\n  // Mark client as active\n  this._updateIdle(true);\n\n  if (self.timeout) {\n    log.trace('Setting timeout to %d', self.timeout);\n    timer = setTimeout(onRequestTimeout, self.timeout);\n  }\n\n  if (log.trace())\n    log.trace('sending request %j', message.json);\n\n  try {\n    return conn.write(message.toBer(), writeCallback);\n  } catch (e) {\n    if (timer)\n      clearTimeout(timer);\n\n    log.trace({err: e}, 'Error writing message to socket');\n    return callback(e);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/attribute.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\n\nvar asn1 = require('asn1');\n\nvar Protocol = require('./protocol');\n\n\n///--- API\n\nfunction Attribute(options) {\n  if (options) {\n    if (typeof (options) !== 'object')\n      throw new TypeError('options must be an object');\n    if (options.type && typeof (options.type) !== 'string')\n      throw new TypeError('options.type must be a string');\n  } else {\n    options = {};\n  }\n\n  this.type = options.type || '';\n  this._vals = [];\n\n  if (options.vals !== undefined && options.vals !== null)\n    this.vals = options.vals;\n}\n\nmodule.exports = Attribute;\n\nObject.defineProperties(Attribute.prototype, {\n  buffers: {\n    get: function getBuffers() {\n      return this._vals;\n    },\n    configurable: false\n  },\n  json: {\n    get: function getJson() {\n      return {\n        type: this.type,\n        vals: this.vals\n      };\n    },\n    configurable: false\n  },\n  vals: {\n    get: function getVals() {\n      var eType = _bufferEncoding(this.type);\n      return this._vals.map(function (v) {\n        return v.toString(eType);\n      });\n    },\n    set: function setVals(vals) {\n      var self = this;\n      this._vals = [];\n      if (Array.isArray(vals)) {\n        vals.forEach(function (v) {\n          self.addValue(v);\n        });\n      } else {\n        self.addValue(vals);\n      }\n    },\n    configurable: false\n  }\n});\n\n\nAttribute.prototype.addValue = function addValue(val) {\n  if (Buffer.isBuffer(val)) {\n    this._vals.push(val);\n  } else {\n    this._vals.push(new Buffer(val + '', _bufferEncoding(this.type)));\n  }\n};\n\n\n/* BEGIN JSSTYLED */\nAttribute.compare = function compare(a, b) {\n  if (!(Attribute.isAttribute(a)) || !(Attribute.isAttribute(b))) {\n    throw new TypeError('can only compare Attributes');\n  }\n\n  if (a.type < b.type) return -1;\n  if (a.type > b.type) return 1;\n  if (a.vals.length < b.vals.length) return -1;\n  if (a.vals.length > b.vals.length) return 1;\n\n  for (var i = 0; i < a.vals.length; i++) {\n    if (a.vals[i] < b.vals[i]) return -1;\n    if (a.vals[i] > b.vals[i]) return 1;\n  }\n\n  return 0;\n};\n/* END JSSTYLED */\n\n\nAttribute.prototype.parse = function parse(ber) {\n  assert.ok(ber);\n\n  ber.readSequence();\n  this.type = ber.readString();\n\n  if (ber.peek() === Protocol.LBER_SET) {\n    if (ber.readSequence(Protocol.LBER_SET)) {\n      var end = ber.offset + ber.length;\n      while (ber.offset < end)\n        this._vals.push(ber.readString(asn1.Ber.OctetString, true));\n    }\n  }\n\n  return true;\n};\n\n\nAttribute.prototype.toBer = function toBer(ber) {\n  assert.ok(ber);\n\n  ber.startSequence();\n  ber.writeString(this.type);\n  ber.startSequence(Protocol.LBER_SET);\n  if (this._vals.length) {\n    this._vals.forEach(function (b) {\n      ber.writeByte(asn1.Ber.OctetString);\n      ber.writeLength(b.length);\n      for (var i = 0; i < b.length; i++)\n        ber.writeByte(b[i]);\n    });\n  } else {\n    ber.writeStringArray([]);\n  }\n  ber.endSequence();\n  ber.endSequence();\n\n  return ber;\n};\n\n\nAttribute.prototype.toString = function () {\n  return JSON.stringify(this.json);\n};\n\n\nAttribute.toBer = function (attr, ber) {\n  return Attribute.prototype.toBer.call(attr, ber);\n};\n\n\nAttribute.isAttribute = function isAttribute(attr) {\n  if (!attr || typeof (attr) !== 'object') {\n    return false;\n  }\n  if (attr instanceof Attribute) {\n    return true;\n  }\n  if ((typeof (attr.toBer) === 'function') &&\n      (typeof (attr.type) === 'string') &&\n      (Array.isArray(attr.vals)) &&\n      (attr.vals.filter(function (item) {\n         return (typeof (item) === 'string' ||\n                  Buffer.isBuffer(item));\n       }).length === attr.vals.length)) {\n    return true;\n  }\n  return false;\n};\n\n\nfunction _bufferEncoding(type) {\n  /* JSSTYLED */\n  return /;binary$/.test(type) ? 'base64' : 'utf8';\n}\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/protocol.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\n\nmodule.exports = {\n\n  // Misc\n  LDAP_VERSION_3: 0x03,\n  LBER_SET: 0x31,\n  LDAP_CONTROLS: 0xa0,\n\n  // Search\n  SCOPE_BASE_OBJECT: 0,\n  SCOPE_ONE_LEVEL: 1,\n  SCOPE_SUBTREE: 2,\n\n  NEVER_DEREF_ALIASES: 0,\n  DEREF_IN_SEARCHING: 1,\n  DEREF_BASE_OBJECT: 2,\n  DEREF_ALWAYS: 3,\n\n  FILTER_AND: 0xa0,\n  FILTER_OR: 0xa1,\n  FILTER_NOT: 0xa2,\n  FILTER_EQUALITY: 0xa3,\n  FILTER_SUBSTRINGS: 0xa4,\n  FILTER_GE: 0xa5,\n  FILTER_LE: 0xa6,\n  FILTER_PRESENT: 0x87,\n  FILTER_APPROX: 0xa8,\n  FILTER_EXT: 0xa9,\n\n  // Protocol Operations\n  LDAP_REQ_BIND: 0x60,\n  LDAP_REQ_UNBIND: 0x42,\n  LDAP_REQ_SEARCH: 0x63,\n  LDAP_REQ_MODIFY: 0x66,\n  LDAP_REQ_ADD: 0x68,\n  LDAP_REQ_DELETE: 0x4a,\n  LDAP_REQ_MODRDN: 0x6c,\n  LDAP_REQ_COMPARE: 0x6e,\n  LDAP_REQ_ABANDON: 0x50,\n  LDAP_REQ_EXTENSION: 0x77,\n\n  LDAP_REP_BIND: 0x61,\n  LDAP_REP_SEARCH_ENTRY: 0x64,\n  LDAP_REP_SEARCH_REF: 0x73,\n  LDAP_REP_SEARCH: 0x65,\n  LDAP_REP_MODIFY: 0x67,\n  LDAP_REP_ADD: 0x69,\n  LDAP_REP_DELETE: 0x6b,\n  LDAP_REP_MODRDN: 0x6d,\n  LDAP_REP_COMPARE: 0x6f,\n  LDAP_REP_EXTENSION: 0x78\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/change.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\n\nvar Attribute = require('./attribute');\nvar Protocol = require('./protocol');\n\n\n///--- API\n\nfunction Change(options) {\n  if (options) {\n    assert.object(options);\n    assert.optionalString(options.operation);\n  } else {\n    options = {};\n  }\n\n  this._modification = false;\n  this.operation = options.operation || options.type || 'add';\n  this.modification = options.modification || {};\n}\nObject.defineProperties(Change.prototype, {\n  operation: {\n    get: function getOperation() {\n      switch (this._operation) {\n      case 0x00: return 'add';\n      case 0x01: return 'delete';\n      case 0x02: return 'replace';\n      default:\n        throw new Error('0x' + this._operation.toString(16) + ' is invalid');\n      }\n    },\n    set: function setOperation(val) {\n      assert.string(val);\n      switch (val.toLowerCase()) {\n      case 'add':\n        this._operation = 0x00;\n        break;\n      case 'delete':\n        this._operation = 0x01;\n        break;\n      case 'replace':\n        this._operation = 0x02;\n        break;\n      default:\n        throw new Error('Invalid operation type: 0x' + val.toString(16));\n      }\n    },\n    configurable: false\n  },\n  modification: {\n    get: function getModification() {\n      return this._modification;\n    },\n    set: function setModification(val) {\n      if (Attribute.isAttribute(val)) {\n        this._modification = val;\n        return;\n      }\n      // Does it have an attribute-like structure\n      if (Object.keys(val).length == 2 &&\n          typeof (val.type) === 'string' &&\n          Array.isArray(val.vals)) {\n        this._modification = new Attribute({\n          type: val.type,\n          vals: val.vals\n        });\n        return;\n      }\n\n      var keys = Object.keys(val);\n      if (keys.length > 1) {\n        throw new Error('Only one attribute per Change allowed');\n      } else if (keys.length === 0) {\n        return;\n      }\n\n      var k = keys[0];\n      var _attr = new Attribute({type: k});\n      if (Array.isArray(val[k])) {\n        val[k].forEach(function (v) {\n          _attr.addValue(v.toString());\n        });\n      } else {\n        _attr.addValue(val[k].toString());\n      }\n      this._modification = _attr;\n    },\n    configurable: false\n  },\n  json: {\n    get: function getJSON() {\n      return {\n        operation: this.operation,\n        modification: this._modification ? this._modification.json : {}\n      };\n    },\n    configurable: false\n  }\n});\n\nChange.isChange = function isChange(change) {\n  if (!change || typeof (change) !== 'object') {\n    return false;\n  }\n  if ((change instanceof Change) ||\n      ((typeof (change.toBer) === 'function') &&\n      (change.modification !== undefined) &&\n      (change.operation !== undefined))) {\n    return true;\n  }\n  return false;\n};\n\nChange.compare = function (a, b) {\n  if (!Change.isChange(a) || !Change.isChange(b))\n    throw new TypeError('can only compare Changes');\n\n  if (a.operation < b.operation)\n    return -1;\n  if (a.operation > b.operation)\n    return 1;\n\n  return Attribute.compare(a.modification, b.modification);\n};\n\n/**\n * Apply a Change to properties of an object.\n *\n * @param {Object} change the change to apply.\n * @param {Object} obj the object to apply it to.\n * @param {Boolean} scalar convert single-item arrays to scalars. Default: false\n */\nChange.apply = function apply(change, obj, scalar) {\n  assert.string(change.operation);\n  assert.string(change.modification.type);\n  assert.ok(Array.isArray(change.modification.vals));\n  assert.object(obj);\n\n  var type = change.modification.type;\n  var vals = change.modification.vals;\n  var data = obj[type];\n  if (data !== undefined) {\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n  } else {\n    data = [];\n  }\n  switch (change.operation) {\n  case 'replace':\n    if (vals.length === 0) {\n      // replace empty is a delete\n      delete obj[type];\n      return obj;\n    } else {\n      data = vals;\n    }\n    break;\n  case 'add':\n    // add only new unique entries\n    var newValues = vals.filter(function (entry) {\n      return (data.indexOf(entry) === -1);\n    });\n    data = data.concat(newValues);\n    break;\n  case 'delete':\n    data = data.filter(function (entry) {\n      return (vals.indexOf(entry) === -1);\n    });\n    if (data.length === 0) {\n      // Erase the attribute if empty\n      delete obj[type];\n      return obj;\n    }\n    break;\n  default:\n    break;\n  }\n  if (scalar && data.length === 1) {\n    // store single-value outputs as scalars, if requested\n    obj[type] = data[0];\n  } else {\n    obj[type] = data;\n  }\n  return obj;\n};\n\n\nChange.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  ber.readSequence();\n  this._operation = ber.readEnumeration();\n  this._modification = new Attribute();\n  this._modification.parse(ber);\n\n  return true;\n};\n\n\nChange.prototype.toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.startSequence();\n  ber.writeEnumeration(this._operation);\n  ber = this._modification.toBer(ber);\n  ber.endSequence();\n\n  return ber;\n};\n\n\n///--- Exports\n\nmodule.exports = Change;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/index.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar Ber = require('asn1').Ber;\n\nvar Control = require('./control');\nvar EntryChangeNotificationControl =\n  require('./entry_change_notification_control');\nvar PersistentSearchControl = require('./persistent_search_control');\nvar PagedResultsControl = require('./paged_results_control');\nvar ServerSideSortingRequestControl =\n  require('./server_side_sorting_request_control.js');\nvar ServerSideSortingResponseControl =\n  require('./server_side_sorting_response_control.js');\n\n\n\n///--- API\n\nmodule.exports = {\n\n  getControl: function getControl(ber) {\n    assert.ok(ber);\n\n    if (ber.readSequence() === null)\n      return null;\n\n    var type;\n    var opts = {\n      criticality: false,\n      value: null\n    };\n\n    if (ber.length) {\n      var end = ber.offset + ber.length;\n\n      type = ber.readString();\n      if (ber.offset < end) {\n        if (ber.peek() === Ber.Boolean)\n          opts.criticality = ber.readBoolean();\n      }\n\n      if (ber.offset < end)\n        opts.value = ber.readString(Ber.OctetString, true);\n    }\n\n    var control;\n    switch (type) {\n    case PersistentSearchControl.OID:\n      control = new PersistentSearchControl(opts);\n      break;\n    case EntryChangeNotificationControl.OID:\n      control = new EntryChangeNotificationControl(opts);\n      break;\n    case PagedResultsControl.OID:\n      control = new PagedResultsControl(opts);\n      break;\n    case ServerSideSortingRequestControl.OID:\n      control = new ServerSideSortingRequestControl(opts);\n      break;\n    case ServerSideSortingResponseControl.OID:\n      control = new ServerSideSortingResponseControl(opts);\n      break;\n    default:\n      opts.type = type;\n      control = new Control(opts);\n      break;\n    }\n\n    return control;\n  },\n\n  Control: Control,\n  EntryChangeNotificationControl: EntryChangeNotificationControl,\n  PagedResultsControl: PagedResultsControl,\n  PersistentSearchControl: PersistentSearchControl,\n  ServerSideSortingRequestControl: ServerSideSortingRequestControl,\n  ServerSideSortingResponseControl: ServerSideSortingResponseControl\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/control.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\n\n\n///--- API\n\nfunction Control(options) {\n  assert.optionalObject(options);\n  options = options || {};\n  assert.optionalString(options.type);\n  assert.optionalBool(options.criticality);\n  if (options.value) {\n    assert.buffer(options.value);\n  }\n\n  this.type = options.type || '';\n  this.criticality = options.critical || options.criticality || false;\n  this.value = options.value || null;\n}\nObject.defineProperties(Control.prototype, {\n  json: {\n    get: function getJson() {\n      var obj = {\n        controlType: this.type,\n        criticality: this.criticality,\n        controlValue: this.value\n      };\n      return (typeof (this._json) === 'function' ? this._json(obj) : obj);\n    }\n  }\n});\n\nControl.prototype.toBer = function toBer(ber) {\n  assert.ok(ber);\n\n  ber.startSequence();\n  ber.writeString(this.type || '');\n  ber.writeBoolean(this.criticality);\n  if (typeof (this._toBer) === 'function') {\n    this._toBer(ber);\n  } else {\n    if (this.value)\n      ber.writeString(this.value);\n  }\n\n  ber.endSequence();\n  return;\n};\n\nControl.prototype.toString = function toString() {\n  return this.json;\n};\n\n\n///--- Exports\nmodule.exports = Control;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/entry_change_notification_control.js":"var assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Control = require('./control');\n\n\n///--- Globals\n\nvar BerReader = asn1.BerReader;\nvar BerWriter = asn1.BerWriter;\n\n\n///--- API\n\nfunction EntryChangeNotificationControl(options) {\n  assert.optionalObject(options);\n  options = options || {};\n  options.type = EntryChangeNotificationControl.OID;\n  if (options.value) {\n    if (Buffer.isBuffer(options.value)) {\n      this.parse(options.value);\n    } else if (typeof (options.value) === 'object') {\n      this._value = options.value;\n    } else {\n      throw new TypeError('options.value must be a Buffer or Object');\n    }\n    options.value = null;\n  }\n  Control.call(this, options);\n}\nutil.inherits(EntryChangeNotificationControl, Control);\nObject.defineProperties(EntryChangeNotificationControl.prototype, {\n  value: {\n    get: function () { return this._value || {}; },\n    configurable: false\n  }\n});\n\nEntryChangeNotificationControl.prototype.parse = function parse(buffer) {\n  assert.ok(buffer);\n\n  var ber = new BerReader(buffer);\n  if (ber.readSequence()) {\n    this._value = {\n      changeType: ber.readInt()\n    };\n\n    // if the operation was moddn, then parse the optional previousDN attr\n    if (this._value.changeType === 8)\n      this._value.previousDN = ber.readString();\n\n    this._value.changeNumber = ber.readInt();\n\n    return true;\n  }\n\n  return false;\n};\n\nEntryChangeNotificationControl.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (!this._value)\n    return;\n\n  var writer = new BerWriter();\n  writer.startSequence();\n  writer.writeInt(this.value.changeType);\n  if (this.value.previousDN)\n    writer.writeString(this.value.previousDN);\n\n  writer.writeInt(parseInt(this.value.changeNumber, 10));\n  writer.endSequence();\n\n  ber.writeBuffer(writer.buffer, 0x04);\n};\n\nEntryChangeNotificationControl.prototype._json = function (obj) {\n  obj.controlValue = this.value;\n  return obj;\n};\n\nEntryChangeNotificationControl.OID = '2.16.840.1.113730.3.4.7';\n\n\n///--- Exports\nmodule.exports = EntryChangeNotificationControl;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/persistent_search_control.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Control = require('./control');\n\n\n///--- Globals\n\nvar BerReader = asn1.BerReader;\nvar BerWriter = asn1.BerWriter;\n\n\n///--- API\n\nfunction PersistentSearchControl(options) {\n  assert.optionalObject(options);\n  options = options || {};\n  options.type = PersistentSearchControl.OID;\n\n  if (options.value) {\n    if (Buffer.isBuffer(options.value)) {\n      this.parse(options.value);\n    } else if (typeof (options.value) === 'object') {\n      this._value = options.value;\n    } else {\n      throw new TypeError('options.value must be a Buffer or Object');\n    }\n    options.value = null;\n  }\n  Control.call(this, options);\n}\nutil.inherits(PersistentSearchControl, Control);\nObject.defineProperties(PersistentSearchControl.prototype, {\n  value: {\n    get: function () { return this._value || {}; },\n    configurable: false\n  }\n});\n\nPersistentSearchControl.prototype.parse = function parse(buffer) {\n  assert.ok(buffer);\n\n  var ber = new BerReader(buffer);\n  if (ber.readSequence()) {\n    this._value = {\n      changeTypes: ber.readInt(),\n      changesOnly: ber.readBoolean(),\n      returnECs: ber.readBoolean()\n    };\n\n    return true;\n  }\n\n  return false;\n};\n\nPersistentSearchControl.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (!this._value)\n    return;\n\n  var writer = new BerWriter();\n  writer.startSequence();\n  writer.writeInt(this.value.changeTypes);\n  writer.writeBoolean(this.value.changesOnly);\n  writer.writeBoolean(this.value.returnECs);\n  writer.endSequence();\n\n  ber.writeBuffer(writer.buffer, 0x04);\n};\n\nPersistentSearchControl.prototype._json = function (obj) {\n  obj.controlValue = this.value;\n  return obj;\n};\n\nPersistentSearchControl.OID = '2.16.840.1.113730.3.4.3';\n\n///--- Exports\nmodule.exports = PersistentSearchControl;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/paged_results_control.js":"var assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Control = require('./control');\n\n\n///--- Globals\n\nvar BerReader = asn1.BerReader;\nvar BerWriter = asn1.BerWriter;\n\n\n///--- API\n\nfunction PagedResultsControl(options) {\n  assert.optionalObject(options);\n  options = options || {};\n  options.type = PagedResultsControl.OID;\n  if (options.value) {\n    if (Buffer.isBuffer(options.value)) {\n      this.parse(options.value);\n    } else if (typeof (options.value) === 'object') {\n      this._value = options.value;\n    } else {\n      throw new TypeError('options.value must be a Buffer or Object');\n    }\n    options.value = null;\n  }\n  Control.call(this, options);\n}\nutil.inherits(PagedResultsControl, Control);\nObject.defineProperties(PagedResultsControl.prototype, {\n  value: {\n    get: function () { return this._value || {}; },\n    configurable: false\n  }\n});\n\nPagedResultsControl.prototype.parse = function parse(buffer) {\n  assert.ok(buffer);\n\n  var ber = new BerReader(buffer);\n  if (ber.readSequence()) {\n    this._value = {};\n    this._value.size = ber.readInt();\n    this._value.cookie = ber.readString(asn1.Ber.OctetString, true);\n     //readString returns '' instead of a zero-length buffer\n    if (!this._value.cookie)\n      this._value.cookie = new Buffer(0);\n\n    return true;\n  }\n\n  return false;\n};\n\nPagedResultsControl.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (!this._value)\n    return;\n\n  var writer = new BerWriter();\n  writer.startSequence();\n  writer.writeInt(this.value.size);\n  if (this.value.cookie && this.value.cookie.length > 0) {\n    writer.writeBuffer(this.value.cookie, asn1.Ber.OctetString);\n  } else {\n    writer.writeString(''); //writeBuffer rejects zero-length buffers\n  }\n  writer.endSequence();\n\n  ber.writeBuffer(writer.buffer, 0x04);\n};\n\nPagedResultsControl.prototype._json = function (obj) {\n  obj.controlValue = this.value;\n  return obj;\n};\n\nPagedResultsControl.OID = '1.2.840.113556.1.4.319';\n\n\n///--- Exports\nmodule.exports = PagedResultsControl;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/server_side_sorting_request_control.js":"var assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Control = require('./control');\n\n\n///--- Globals\n\nvar BerReader = asn1.BerReader;\nvar BerWriter = asn1.BerWriter;\n\n\n///--- API\n\nfunction ServerSideSortingRequestControl(options) {\n  assert.optionalObject(options);\n  options = options || {};\n  options.type = ServerSideSortingRequestControl.OID;\n  if (options.value) {\n    if (Buffer.isBuffer(options.value)) {\n      this.parse(options.value);\n    } else if (Array.isArray(options.value)) {\n      assert.arrayOfObject(options.value, 'options.value must be Objects');\n      for (var i = 0; i < options.value.length; i++) {\n        if (!options.value[i].hasOwnProperty('attributeType')) {\n          throw new Error('Missing required key: attributeType');\n        }\n      }\n      this._value = options.value;\n    } else if (typeof (options.value) === 'object') {\n      if (!options.value.hasOwnProperty('attributeType')) {\n        throw new Error('Missing required key: attributeType');\n      }\n      this._value = [options.value];\n    } else {\n      throw new TypeError('options.value must be a Buffer, Array or Object');\n    }\n    options.value = null;\n  }\n  Control.call(this, options);\n}\nutil.inherits(ServerSideSortingRequestControl, Control);\nObject.defineProperties(ServerSideSortingRequestControl.prototype, {\n  value: {\n    get: function () { return this._value || []; },\n    configurable: false\n  }\n});\n\nServerSideSortingRequestControl.prototype.parse = function parse(buffer) {\n  assert.ok(buffer);\n\n  var ber = new BerReader(buffer);\n  var item;\n  if (ber.readSequence(0x30)) {\n    this._value = [];\n\n    while (ber.readSequence(0x30)) {\n      item = {};\n      item.attributeType = ber.readString(asn1.Ber.OctetString);\n      if (ber.peek() == 0x80) {\n        item.orderingRule = ber.readString(0x80);\n      }\n      if (ber.peek() == 0x81) {\n        item.reverseOrder = (ber._readTag(0x81) === 0 ? false : true);\n      }\n      this._value.push(item);\n    }\n    return true;\n  }\n  return false;\n};\n\nServerSideSortingRequestControl.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (!this._value || this.value.length === 0)\n    return;\n\n  var writer = new BerWriter();\n  writer.startSequence(0x30);\n  for (var i = 0; i < this.value.length; i++) {\n    var item = this.value[i];\n    writer.startSequence(0x30);\n    if (item.attributeType) {\n      writer.writeString(item.attributeType, asn1.Ber.OctetString);\n    }\n    if (item.orderingRule) {\n      writer.writeString(item.orderingRule, 0x80);\n    }\n    if (item.reverseOrder) {\n      writer.writeBoolean(item.reverseOrder, 0x81);\n    }\n    writer.endSequence();\n  }\n  writer.endSequence();\n  ber.writeBuffer(writer.buffer, 0x04);\n};\n\nServerSideSortingRequestControl.prototype._json = function (obj) {\n  obj.controlValue = this.value;\n  return obj;\n};\n\nServerSideSortingRequestControl.OID = '1.2.840.113556.1.4.473';\n\n\n///---Exports\n\nmodule.exports = ServerSideSortingRequestControl;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/controls/server_side_sorting_response_control.js":"var assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Control = require('./control');\nvar CODES = require('../errors/codes');\n\n\n///--- Globals\n\nvar BerReader = asn1.BerReader;\nvar BerWriter = asn1.BerWriter;\n\nvar VALID_CODES = [\n  CODES.LDAP_SUCCESS,\n  CODES.LDAP_OPERATIONS_ERROR,\n  CODES.LDAP_TIME_LIMIT_EXCEEDED,\n  CODES.LDAP_STRONG_AUTH_REQUIRED,\n  CODES.LDAP_ADMIN_LIMIT_EXCEEDED,\n  CODES.LDAP_NO_SUCH_ATTRIBUTE,\n  CODES.LDAP_INAPPROPRIATE_MATCHING,\n  CODES.LDAP_INSUFFICIENT_ACCESS_RIGHTS,\n  CODES.LDAP_BUSY,\n  CODES.LDAP_UNWILLING_TO_PERFORM,\n  CODES.LDAP_OTHER\n];\n\nfunction ServerSideSortingResponseControl(options) {\n  assert.optionalObject(options);\n  options = options || {};\n  options.type = ServerSideSortingResponseControl.OID;\n  options.criticality = false;\n\n  if (options.value) {\n    if (Buffer.isBuffer(options.value)) {\n      this.parse(options.value);\n    } else if (typeof (options.value) === 'object') {\n      if (VALID_CODES.indexOf(options.value.result) === -1) {\n        throw new Error('Invalid result code');\n      }\n      if (options.value.failedAttribute &&\n          typeof (options.value.failedAttribute) !== 'string') {\n        throw new Error('failedAttribute must be String');\n      }\n\n      this._value = options.value;\n    } else {\n      throw new TypeError('options.value must be a Buffer or Object');\n    }\n    options.value = null;\n  }\n  Control.call(this, options);\n}\nutil.inherits(ServerSideSortingResponseControl, Control);\nObject.defineProperties(ServerSideSortingResponseControl.prototype, {\n  value: {\n    get: function () { return this._value || {}; },\n    configurable: false\n  }\n});\n\nServerSideSortingResponseControl.prototype.parse = function parse(buffer) {\n  assert.ok(buffer);\n\n  var ber = new BerReader(buffer);\n  if (ber.readSequence(0x30)) {\n    this._value = {};\n    this._value.result = ber.readEnumeration();\n    if (ber.peek() == 0x80) {\n      this._value.failedAttribute = ber.readString(0x80);\n    }\n    return true;\n  }\n  return false;\n};\n\nServerSideSortingResponseControl.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (!this._value || this.value.length === 0)\n    return;\n\n  var writer = new BerWriter();\n  writer.startSequence(0x30);\n  writer.writeEnumeration(this.value.result);\n  if (this.value.result !== CODES.LDAP_SUCCESS && this.value.failedAttribute) {\n    writer.writeString(this.value.failedAttribute, 0x80);\n  }\n  writer.endSequence();\n  ber.writeBuffer(writer.buffer, 0x04);\n};\n\nServerSideSortingResponseControl.prototype._json = function (obj) {\n  obj.controlValue = this.value;\n  return obj;\n};\n\nServerSideSortingResponseControl.OID = '1.2.840.113556.1.4.474';\n\n\n///--- Exports\nmodule.exports = ServerSideSortingResponseControl;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/errors/codes.js":"// Copyright 2014 Joyent, Inc.  All rights reserved.\n\nmodule.exports = {\n  LDAP_SUCCESS: 0,\n  LDAP_OPERATIONS_ERROR: 1,\n  LDAP_PROTOCOL_ERROR: 2,\n  LDAP_TIME_LIMIT_EXCEEDED: 3,\n  LDAP_SIZE_LIMIT_EXCEEDED: 4,\n  LDAP_COMPARE_FALSE: 5,\n  LDAP_COMPARE_TRUE: 6,\n  LDAP_AUTH_METHOD_NOT_SUPPORTED: 7,\n  LDAP_STRONG_AUTH_REQUIRED: 8,\n  LDAP_REFERRAL: 10,\n  LDAP_ADMIN_LIMIT_EXCEEDED: 11,\n  LDAP_UNAVAILABLE_CRITICAL_EXTENSION: 12,\n  LDAP_CONFIDENTIALITY_REQUIRED: 13,\n  LDAP_SASL_BIND_IN_PROGRESS: 14,\n  LDAP_NO_SUCH_ATTRIBUTE: 16,\n  LDAP_UNDEFINED_ATTRIBUTE_TYPE: 17,\n  LDAP_INAPPROPRIATE_MATCHING: 18,\n  LDAP_CONSTRAINT_VIOLATION: 19,\n  LDAP_ATTRIBUTE_OR_VALUE_EXISTS: 20,\n  LDAP_INVALID_ATTRIBUTE_SYNTAX: 21,\n  LDAP_NO_SUCH_OBJECT: 32,\n  LDAP_ALIAS_PROBLEM: 33,\n  LDAP_INVALID_DN_SYNTAX: 34,\n  LDAP_ALIAS_DEREF_PROBLEM: 36,\n  LDAP_INAPPROPRIATE_AUTHENTICATION: 48,\n  LDAP_INVALID_CREDENTIALS: 49,\n  LDAP_INSUFFICIENT_ACCESS_RIGHTS: 50,\n  LDAP_BUSY: 51,\n  LDAP_UNAVAILABLE: 52,\n  LDAP_UNWILLING_TO_PERFORM: 53,\n  LDAP_LOOP_DETECT: 54,\n  LDAP_NAMING_VIOLATION: 64,\n  LDAP_OBJECTCLASS_VIOLATION: 65,\n  LDAP_NOT_ALLOWED_ON_NON_LEAF: 66,\n  LDAP_NOT_ALLOWED_ON_RDN: 67,\n  LDAP_ENTRY_ALREADY_EXISTS: 68,\n  LDAP_OBJECTCLASS_MODS_PROHIBITED: 69,\n  LDAP_AFFECTS_MULTIPLE_DSAS: 71,\n  LDAP_OTHER: 80,\n  LDAP_PROXIED_AUTHORIZATION_DENIED: 123\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/client/search_pager.js":"// Copyright 2014 Joyent, Inc.  All rights reserved.\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar assert = require('assert-plus');\n\nvar dn = require('../dn');\nvar messages = require('../messages/index');\nvar Protocol = require('../protocol');\nvar PagedControl = require('../controls/paged_results_control.js');\n\n\n///--- API\n\n\n/**\n * Handler object for paged search operations.\n *\n * Provided to consumers in place of the normal search EventEmitter it adds the\n * following new events:\n * 1. page      - Emitted whenever the end of a result page is encountered.\n *                If this is the last page, 'end' will also be emitted.\n *                The event passes two arguments:\n *                1. The result object (similar to 'end')\n *                2. A callback function optionally used to continue the search\n *                   operation if the pagePause option was specified during\n *                   initialization.\n * 2. pageError - Emitted if the server does not support paged search results\n *                If there are no listeners for this event, the 'error' event\n *                will be emitted (and 'end' will not be).  By listening to\n *                'pageError', a successful search that lacks paging will be\n *                able to emit 'end'.\n * 3. search    - Emitted as an internal event to trigger another client search.\n */\nfunction SearchPager(opts) {\n  assert.object(opts);\n  assert.func(opts.callback);\n  assert.number(opts.pageSize);\n\n  EventEmitter.call(this, {});\n\n  this.callback = opts.callback;\n  this.controls = opts.controls;\n  this.pageSize = opts.pageSize;\n  this.pagePause = opts.pagePause;\n\n  this.controls.forEach(function (control) {\n    if (control.type === PagedControl.OID) {\n      // The point of using SearchPager is not having to do this.\n      // Toss an error if the pagedResultsControl is present\n      throw new Error('redundant pagedResultControl');\n    }\n  });\n\n  this.finished = false;\n  this.started = false;\n\n  var emitter = new EventEmitter();\n  emitter.on('searchEntry', this.emit.bind(this, 'searchEntry'));\n  emitter.on('end', this._onEnd.bind(this));\n  emitter.on('error',  this._onError.bind(this));\n  this.childEmitter = emitter;\n}\nutil.inherits(SearchPager, EventEmitter);\nmodule.exports = SearchPager;\n\n/**\n * Start the paged search.\n */\nSearchPager.prototype.begin = function begin() {\n  // Starting first page\n  this._nextPage(null);\n};\n\nSearchPager.prototype._onEnd = function _onEnd(res) {\n  var self = this;\n  var cookie = null;\n  res.controls.forEach(function (control) {\n    if (control.type === PagedControl.OID) {\n      cookie = control.value.cookie;\n    }\n  });\n  // Pass a noop callback by default for page events\n  var nullCb = function () { };\n\n  if (cookie === null) {\n    // paged search not supported\n    this.finished = true;\n    this.emit('page', res, nullCb);\n    var err = new Error('missing paged control');\n    err.name = 'PagedError';\n    if (this.listeners('pageError').length > 0) {\n      this.emit('pageError', err);\n      // If the consumer as subscribed to pageError, SearchPager is absolved\n      // from deliverying the fault via the 'error' event.  Emitting an 'end'\n      // event after 'error' breaks the contract that the standard client\n      // provides, so it's only a possibility if 'pageError' is used instead.\n      this.emit('end', res);\n    } else {\n      this.emit('error', err);\n      // No end event possible per explaination above.\n    }\n    return;\n  }\n\n  if (cookie.length === 0) {\n    // end of paged results\n    this.finished = true;\n    this.emit('page', nullCb);\n    this.emit('end', res);\n  } else {\n    if (this.pagePause) {\n      // Wait to fetch next page until callback is invoked\n      // Halt page fetching if called with error\n      this.emit('page', res, function (err) {\n        if (!err) {\n          self._nextPage(cookie);\n        } else {\n          // the paged search has been canceled so emit an end\n          self.emit('end', res);\n        }\n      });\n    } else {\n      this.emit('page', res, nullCb);\n      this._nextPage(cookie);\n    }\n  }\n};\n\nSearchPager.prototype._onError = function _onError(err) {\n  this.finished = true;\n  this.emit('error', err);\n};\n\n/**\n * Initiate a search for the next page using the returned cookie value.\n */\nSearchPager.prototype._nextPage = function _nextPage(cookie) {\n  var controls = this.controls.slice(0);\n  controls.push(new PagedControl({\n    value: {\n      size: this.pageSize,\n      cookie: cookie\n    }\n  }));\n\n  this.emit('search', controls, this.childEmitter,\n      this._sendCallback.bind(this));\n};\n\n/**\n * Callback provided to the client API for successful transmission.\n */\nSearchPager.prototype._sendCallback = function _sendCallback(err, res) {\n  if (err) {\n    this.finished = true;\n    if (!this.started) {\n      // EmitSend error during the first page, bail via callback\n      this.callback(err, null);\n    } else {\n      this.emit('error', err);\n    }\n  } else {\n    // search successfully send\n    if (!this.started) {\n      this.started = true;\n      // send self as emitter as the client would\n      this.callback(null, this);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/dn.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\n\nvar assert = require('assert-plus');\n\n\n///--- Helpers\n\nfunction invalidDN(name) {\n  var e = new Error();\n  e.name = 'InvalidDistinguishedNameError';\n  e.message = name;\n  return e;\n}\n\nfunction isAlphaNumeric(c) {\n  var re = /[A-Za-z0-9]/;\n  return re.test(c);\n}\n\nfunction isWhitespace(c) {\n  var re = /\\s/;\n  return re.test(c);\n}\n\nfunction repeatChar(c, n) {\n  var out = '';\n  var max = n ? n : 0;\n  for (var i = 0; i < max; i++)\n    out += c;\n  return out;\n}\n\n///--- API\n\nfunction RDN(obj) {\n  var self = this;\n  this.attrs = {};\n\n  if (obj) {\n    Object.keys(obj).forEach(function (k) {\n      self.set(k, obj[k]);\n    });\n  }\n}\n\nRDN.prototype.set = function rdnSet(name, value, opts) {\n  assert.string(name, 'name (string) required');\n  assert.string(value, 'value (string) required');\n\n  var self = this;\n  var lname = name.toLowerCase();\n  this.attrs[lname] = {\n    value: value,\n    name: name\n  };\n  if (opts && typeof (opts) === 'object') {\n    Object.keys(opts).forEach(function (k) {\n      if (k !== 'value')\n        self.attrs[lname][k] = opts[k];\n    });\n  }\n};\n\nRDN.prototype.equals = function rdnEquals(rdn) {\n  if (typeof (rdn) !== 'object')\n    return false;\n\n  var ourKeys = Object.keys(this.attrs);\n  var theirKeys = Object.keys(rdn.attrs);\n  if (ourKeys.length !== theirKeys.length)\n    return false;\n\n  ourKeys.sort();\n  theirKeys.sort();\n\n  for (var i = 0; i < ourKeys.length; i++) {\n    if (ourKeys[i] !== theirKeys[i])\n      return false;\n    if (this.attrs[ourKeys[i]].value !== rdn.attrs[ourKeys[i]].value)\n      return false;\n  }\n  return true;\n};\n\n\n/**\n * Convert RDN to string according to specified formatting options.\n * (see: DN.format for option details)\n */\nRDN.prototype.format = function rdnFormat(options) {\n  assert.optionalObject(options, 'options must be an object');\n  options = options || {};\n\n  var self = this;\n  var str = '';\n\n  function escapeValue(val, forceQuote) {\n    var out = '';\n    var cur = 0;\n    var len = val.length;\n    var quoted = false;\n    /* BEGIN JSSTYLED */\n    var escaped = /[\\\\\\\"]/;\n    var special = /[,=+<>#;]/;\n    /* END JSSTYLED */\n\n    if (len > 0) {\n      // Wrap strings with trailing or leading spaces in quotes\n      quoted = forceQuote || (val[0] == ' ' || val[len-1] == ' ');\n    }\n\n    while (cur < len) {\n      if (escaped.test(val[cur]) || (!quoted && special.test(val[cur]))) {\n        out += '\\\\';\n      }\n      out += val[cur++];\n    }\n    if (quoted)\n      out = '\"' + out + '\"';\n    return out;\n  }\n  function sortParsed(a, b) {\n    return self.attrs[a].order - self.attrs[b].order;\n  }\n  function sortStandard(a, b) {\n    var nameCompare = a.localeCompare(b);\n    if (nameCompare === 0) {\n      // TODO: Handle binary values\n      return self.attrs[a].value.localeCompare(self.attrs[b].value);\n    } else {\n      return nameCompare;\n    }\n  }\n\n  var keys = Object.keys(this.attrs);\n  if (options.keepOrder) {\n    keys.sort(sortParsed);\n  } else {\n    keys.sort(sortStandard);\n  }\n\n  keys.forEach(function (key) {\n    var attr = self.attrs[key];\n    if (str.length)\n      str += '+';\n\n    if (options.keepCase) {\n      str += attr.name;\n    } else {\n      if (options.upperName)\n        str += key.toUpperCase();\n      else\n        str += key;\n    }\n\n    str += '=' + escapeValue(attr.value, (options.keepQuote && attr.quoted));\n  });\n\n  return str;\n};\n\nRDN.prototype.toString = function rdnToString() {\n  return this.format();\n};\n\n\n// Thank you OpenJDK!\nfunction parse(name) {\n  if (typeof (name) !== 'string')\n    throw new TypeError('name (string) required');\n\n  var cur = 0;\n  var len = name.length;\n\n  function parseRdn() {\n    var rdn = new RDN();\n    var order = 0;\n    rdn.spLead = trim();\n    while (cur < len) {\n      var opts = {\n        order: order\n      };\n      var attr = parseAttrType();\n      trim();\n      if (cur >= len || name[cur++] !== '=')\n        throw invalidDN(name);\n\n      trim();\n      // Parameters about RDN value are set in 'opts' by parseAttrValue\n      var value = parseAttrValue(opts);\n      rdn.set(attr, value, opts);\n      rdn.spTrail = trim();\n      if (cur >= len || name[cur] !== '+')\n        break;\n      ++cur;\n      ++order;\n    }\n    return rdn;\n  }\n\n\n  function trim() {\n    var count = 0;\n    while ((cur < len) && isWhitespace(name[cur])) {\n      ++cur;\n      count++;\n    }\n    return count;\n  }\n\n  function parseAttrType() {\n    var beg = cur;\n    while (cur < len) {\n      var c = name[cur];\n      if (isAlphaNumeric(c) ||\n          c == '.' ||\n          c == '-' ||\n          c == ' ') {\n        ++cur;\n      } else {\n        break;\n      }\n    }\n    // Back out any trailing spaces.\n    while ((cur > beg) && (name[cur - 1] == ' '))\n      --cur;\n\n    if (beg == cur)\n      throw invalidDN(name);\n\n    return name.slice(beg, cur);\n  }\n\n  function parseAttrValue(opts) {\n    if (cur < len && name[cur] == '#') {\n      opts.binary = true;\n      return parseBinaryAttrValue();\n    } else if (cur < len && name[cur] == '\"') {\n      opts.quoted = true;\n      return parseQuotedAttrValue();\n    } else {\n      return parseStringAttrValue();\n    }\n  }\n\n  function parseBinaryAttrValue() {\n    var beg = cur++;\n    while (cur < len && isAlphaNumeric(name[cur]))\n      ++cur;\n\n    return name.slice(beg, cur);\n  }\n\n  function parseQuotedAttrValue() {\n    var str = '';\n    ++cur; // Consume the first quote\n\n    while ((cur < len) && name[cur] != '\"') {\n      if (name[cur] === '\\\\')\n        cur++;\n      str += name[cur++];\n    }\n    if (cur++ >= len) // no closing quote\n      throw invalidDN(name);\n\n    return str;\n  }\n\n  function parseStringAttrValue() {\n    var beg = cur;\n    var str = '';\n    var esc = -1;\n\n    while ((cur < len) && !atTerminator()) {\n      if (name[cur] === '\\\\') {\n        // Consume the backslash and mark its place just in case it's escaping\n        // whitespace which needs to be preserved.\n        esc = cur++;\n      }\n      if (cur === len) // backslash followed by nothing\n        throw invalidDN(name);\n      str += name[cur++];\n    }\n\n    // Trim off (unescaped) trailing whitespace and rewind cursor to the end of\n    // the AttrValue to record whitespace length.\n    for (; cur > beg; cur--) {\n      if (!isWhitespace(name[cur - 1]) || (esc === (cur - 1)))\n        break;\n    }\n    return str.slice(0, cur - beg);\n  }\n\n  function atTerminator() {\n    return (cur < len &&\n            (name[cur] === ',' ||\n             name[cur] === ';' ||\n             name[cur] === '+'));\n  }\n\n  var rdns = [];\n\n  // Short-circuit for empty DNs\n  if (len === 0)\n    return new DN(rdns);\n\n  rdns.push(parseRdn());\n  while (cur < len) {\n    if (name[cur] === ',' || name[cur] === ';') {\n      ++cur;\n      rdns.push(parseRdn());\n    } else {\n      throw invalidDN(name);\n    }\n  }\n\n  return new DN(rdns);\n}\n\n\nfunction DN(rdns) {\n  assert.optionalArrayOfObject(rdns, '[object] required');\n\n  this.rdns = rdns ? rdns.slice() : [];\n  this._format = {};\n}\nObject.defineProperties(DN.prototype, {\n  length: {\n    get: function getLength() { return this.rdns.length; },\n    configurable: false\n  }\n});\n\n/**\n * Convert DN to string according to specified formatting options.\n *\n * Parameters:\n * - options: formatting parameters (optional, details below)\n *\n * Options are divided into two types:\n * - Preservation options: Using data recorded during parsing, details of the\n *   original DN are preserved when converting back into a string.\n * - Modification options: Alter string formatting defaults.\n *\n * Preservation options _always_ take precedence over modification options.\n *\n * Preservation Options:\n * - keepOrder: Order of multi-value RDNs.\n * - keepQuote: RDN values which were quoted will remain so.\n * - keepSpace: Leading/trailing spaces will be output.\n * - keepCase: Parsed attr name will be output instead of lowercased version.\n *\n * Modification Options:\n * - upperName: RDN names will be uppercased instead of lowercased.\n * - skipSpace: Disable trailing space after RDN separators\n */\nDN.prototype.format = function dnFormat(options) {\n  assert.optionalObject(options, 'options must be an object');\n  options = options || this._format;\n\n  var str = '';\n  this.rdns.forEach(function (rdn) {\n    var rdnString = rdn.format(options);\n    if (str.length !== 0) {\n      str += ',';\n    }\n    if (options.keepSpace) {\n      str += (repeatChar(' ', rdn.spLead) +\n        rdnString + repeatChar(' ', rdn.spTrail));\n    } else if (options.skipSpace === true || str.length === 0) {\n      str += rdnString;\n    } else {\n      str += ' ' + rdnString;\n    }\n  });\n  return str;\n};\n\n/**\n * Set default string formatting options.\n */\nDN.prototype.setFormat = function setFormat(options) {\n  assert.object(options, 'options must be an object');\n\n  this._format = options;\n};\n\nDN.prototype.toString = function dnToString() {\n  return this.format();\n};\n\nDN.prototype.parentOf = function parentOf(dn) {\n  if (typeof (dn) !== 'object')\n    dn = parse(dn);\n\n  if (this.rdns.length >= dn.rdns.length)\n    return false;\n\n  var diff = dn.rdns.length - this.rdns.length;\n  for (var i = this.rdns.length - 1; i >= 0; i--) {\n    var myRDN = this.rdns[i];\n    var theirRDN = dn.rdns[i + diff];\n\n    if (!myRDN.equals(theirRDN))\n      return false;\n  }\n\n  return true;\n};\n\nDN.prototype.childOf = function childOf(dn) {\n  if (typeof (dn) !== 'object')\n    dn = parse(dn);\n  return dn.parentOf(this);\n};\n\nDN.prototype.isEmpty = function isEmpty() {\n  return (this.rdns.length === 0);\n};\n\nDN.prototype.equals = function dnEquals(dn) {\n  if (typeof (dn) !== 'object')\n    dn = parse(dn);\n\n  if (this.rdns.length !== dn.rdns.length)\n    return false;\n\n  for (var i = 0; i < this.rdns.length; i++) {\n    if (!this.rdns[i].equals(dn.rdns[i]))\n      return false;\n  }\n\n  return true;\n};\n\nDN.prototype.parent = function dnParent() {\n  if (this.rdns.length !== 0) {\n    var save = this.rdns.shift();\n    var dn = new DN(this.rdns);\n    this.rdns.unshift(save);\n    return dn;\n  }\n\n  return null;\n};\n\nDN.prototype.clone = function dnClone() {\n  var dn = new DN(this.rdns);\n  dn._format = this._format;\n  return dn;\n};\n\nDN.prototype.reverse = function dnReverse() {\n  this.rdns.reverse();\n  return this;\n};\n\nDN.prototype.pop = function dnPop() {\n  return this.rdns.pop();\n};\n\nDN.prototype.push = function dnPush(rdn) {\n  assert.object(rdn, 'rdn (RDN) required');\n\n  return this.rdns.push(rdn);\n};\n\nDN.prototype.shift = function dnShift() {\n  return this.rdns.shift();\n};\n\nDN.prototype.unshift = function dnUnshift(rdn) {\n  assert.object(rdn, 'rdn (RDN) required');\n\n  return this.rdns.unshift(rdn);\n};\n\nDN.isDN = function isDN(dn) {\n  if (!dn || typeof (dn) !== 'object') {\n    return false;\n  }\n  if (dn instanceof DN) {\n    return true;\n  }\n  if (Array.isArray(dn.rdns)) {\n    // Really simple duck-typing for now\n    return true;\n  }\n  return false;\n};\n\n\n///--- Exports\n\nmodule.exports = {\n  parse: parse,\n  DN: DN,\n  RDN: RDN\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/index.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar LDAPMessage = require('./message');\nvar LDAPResult = require('./result');\nvar Parser = require('./parser');\n\nvar AbandonRequest = require('./abandon_request');\nvar AbandonResponse = require('./abandon_response');\nvar AddRequest = require('./add_request');\nvar AddResponse = require('./add_response');\nvar BindRequest = require('./bind_request');\nvar BindResponse = require('./bind_response');\nvar CompareRequest = require('./compare_request');\nvar CompareResponse = require('./compare_response');\nvar DeleteRequest = require('./del_request');\nvar DeleteResponse = require('./del_response');\nvar ExtendedRequest = require('./ext_request');\nvar ExtendedResponse = require('./ext_response');\nvar ModifyRequest = require('./modify_request');\nvar ModifyResponse = require('./modify_response');\nvar ModifyDNRequest = require('./moddn_request');\nvar ModifyDNResponse = require('./moddn_response');\nvar SearchRequest = require('./search_request');\nvar SearchEntry = require('./search_entry');\nvar SearchReference = require('./search_reference');\nvar SearchResponse = require('./search_response');\nvar UnbindRequest = require('./unbind_request');\nvar UnbindResponse = require('./unbind_response');\n\n\n///--- API\n\nmodule.exports = {\n\n  LDAPMessage: LDAPMessage,\n  LDAPResult: LDAPResult,\n  Parser: Parser,\n\n  AbandonRequest: AbandonRequest,\n  AbandonResponse: AbandonResponse,\n  AddRequest: AddRequest,\n  AddResponse: AddResponse,\n  BindRequest: BindRequest,\n  BindResponse: BindResponse,\n  CompareRequest: CompareRequest,\n  CompareResponse: CompareResponse,\n  DeleteRequest: DeleteRequest,\n  DeleteResponse: DeleteResponse,\n  ExtendedRequest: ExtendedRequest,\n  ExtendedResponse: ExtendedResponse,\n  ModifyRequest: ModifyRequest,\n  ModifyResponse: ModifyResponse,\n  ModifyDNRequest: ModifyDNRequest,\n  ModifyDNResponse: ModifyDNResponse,\n  SearchRequest: SearchRequest,\n  SearchEntry: SearchEntry,\n  SearchReference: SearchReference,\n  SearchResponse: SearchResponse,\n  UnbindRequest: UnbindRequest,\n  UnbindResponse: UnbindResponse\n\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/message.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar Control = require('../controls').Control;\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\nvar BerReader = asn1.BerReader;\nvar BerWriter = asn1.BerWriter;\nvar getControl = require('../controls').getControl;\n\n\n///--- API\n\n\n/**\n * LDAPMessage structure.\n *\n * @param {Object} options stuff.\n */\nfunction LDAPMessage(options) {\n  assert.object(options);\n\n  this.messageID = options.messageID || 0;\n  this.protocolOp = options.protocolOp || undefined;\n  this.controls = options.controls ? options.controls.slice(0) : [];\n\n  this.log = options.log;\n}\nObject.defineProperties(LDAPMessage.prototype, {\n  id: {\n    get: function getId() { return this.messageID; },\n    configurable: false\n  },\n  dn: {\n    get: function getDN() { return this._dn || ''; },\n    configurable: false\n  },\n  type: {\n    get: function getType() { return 'LDAPMessage'; },\n    configurable: false\n  },\n  json: {\n    get: function () {\n      var out = this._json({\n        messageID: this.messageID,\n        protocolOp: this.type\n      });\n      out.controls = this.controls;\n      return out;\n    },\n    configurable: false\n  }\n});\n\nLDAPMessage.prototype.toString = function () {\n  return JSON.stringify(this.json);\n};\n\nLDAPMessage.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  if (this.log.trace())\n    this.log.trace('parse: data=%s', util.inspect(ber.buffer));\n\n  // Delegate off to the specific type to parse\n  this._parse(ber, ber.length);\n\n  // Look for controls\n  if (ber.peek() === 0xa0) {\n    ber.readSequence();\n    var end = ber.offset + ber.length;\n    while (ber.offset < end) {\n      var c = getControl(ber);\n      if (c)\n        this.controls.push(c);\n    }\n  }\n\n  if (this.log.trace())\n    this.log.trace('Parsing done: %j', this.json);\n  return true;\n};\n\nLDAPMessage.prototype.toBer = function () {\n  var writer = new BerWriter();\n  writer.startSequence();\n  writer.writeInt(this.messageID);\n\n  writer.startSequence(this.protocolOp);\n  if (this._toBer)\n    writer = this._toBer(writer);\n  writer.endSequence();\n\n  if (this.controls && this.controls.length) {\n    writer.startSequence(0xa0);\n    this.controls.forEach(function (c) {\n      c.toBer(writer);\n    });\n    writer.endSequence();\n  }\n\n  writer.endSequence();\n  return writer.buffer;\n};\n\n\n///--- Exports\n\nmodule.exports = LDAPMessage;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/result.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar dtrace = require('../dtrace');\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\nvar BerWriter = asn1.BerWriter;\n\n\n///--- API\n\nfunction LDAPResult(options) {\n  options = options || {};\n  assert.object(options);\n  assert.optionalNumber(options.status);\n  assert.optionalString(options.matchedDN);\n  assert.optionalString(options.errorMessage);\n  assert.optionalArrayOfString(options.referrals);\n\n  LDAPMessage.call(this, options);\n\n  this.status = options.status || 0; // LDAP SUCCESS\n  this.matchedDN = options.matchedDN || '';\n  this.errorMessage = options.errorMessage || '';\n  this.referrals = options.referrals || [];\n\n  this.connection = options.connection || null;\n}\nutil.inherits(LDAPResult, LDAPMessage);\nObject.defineProperties(LDAPResult.prototype, {\n  type: {\n    get: function getType() { return 'LDAPResult'; },\n    configurable: false\n  }\n});\n\nLDAPResult.prototype.end = function (status) {\n  assert.ok(this.connection);\n\n  if (typeof (status) === 'number')\n    this.status = status;\n\n  var ber = this.toBer();\n  if (this.log.debug())\n    this.log.debug('%s: sending:  %j', this.connection.ldap.id, this.json);\n\n  try {\n    var self = this;\n    this.connection.write(ber);\n\n    if (self._dtraceOp && self._dtraceId) {\n      dtrace.fire('server-' + self._dtraceOp + '-done', function () {\n        var c = self.connection || {ldap: {}};\n        return [\n          self._dtraceId || 0,\n          (c.remoteAddress || ''),\n          c.ldap.bindDN ? c.ldap.bindDN.toString() : '',\n          (self.requestDN ? self.requestDN.toString() : ''),\n          status || self.status,\n          self.errorMessage\n        ];\n      });\n    }\n\n  } catch (e) {\n    this.log.warn(e, '%s failure to write message %j',\n                  this.connection.ldap.id, this.json);\n  }\n\n};\n\nLDAPResult.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.status = ber.readEnumeration();\n  this.matchedDN = ber.readString();\n  this.errorMessage = ber.readString();\n\n  var t = ber.peek();\n\n  if (t === Protocol.LDAP_REP_REFERRAL) {\n    var end = ber.offset + ber.length;\n    while (ber.offset < end)\n      this.referrals.push(ber.readString());\n  }\n\n  return true;\n};\n\nLDAPResult.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeEnumeration(this.status);\n  ber.writeString(this.matchedDN || '');\n  ber.writeString(this.errorMessage || '');\n\n  if (this.referrals.length) {\n    ber.startSequence(Protocol.LDAP_REP_REFERRAL);\n    ber.writeStringArray(this.referrals);\n    ber.endSequence();\n  }\n\n  return ber;\n};\n\nLDAPResult.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.status = this.status;\n  j.matchedDN = this.matchedDN;\n  j.errorMessage = this.errorMessage;\n  j.referrals = this.referrals;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = LDAPResult;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/dtrace.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.s\n\n\n\n///--- Globals\n\nvar SERVER_PROVIDER;\nvar DTRACE_ID = 0;\nvar MAX_INT = 4294967295;\n\n/*\n * Args:\n * server-*-start:\n * 0 -> id\n * 1 -> remoteIP\n * 2 -> bindDN\n * 3 -> req.dn\n * 4,5 -> op specific\n *\n * server-*-done:\n * 0 -> id\n * 1 -> remoteIp\n * 2 -> bindDN\n * 3 -> requsetDN\n * 4 -> status\n * 5 -> errorMessage\n *\n */\nvar SERVER_PROBES = {\n\n  // 4: attributes.length\n  'server-add-start': ['int', 'char *', 'char *', 'char *', 'int'],\n  'server-add-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  'server-bind-start': ['int', 'char *', 'char *', 'char *'],\n  'server-bind-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  // 4: attribute, 5: value\n  'server-compare-start': ['int', 'char *', 'char *', 'char *',\n                           'char *', 'char *'],\n  'server-compare-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  'server-delete-start': ['int', 'char *', 'char *', 'char *'],\n  'server-delete-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  // 4: requestName, 5: requestValue\n  'server-exop-start': ['int', 'char *', 'char *', 'char *', 'char *',\n                        'char *'],\n  'server-exop-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  // 4: changes.length\n  'server-modify-start': ['int', 'char *', 'char *', 'char *', 'int'],\n  'server-modify-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  // 4: newRdn, 5: newSuperior\n  'server-modifydn-start': ['int', 'char *', 'char *', 'char *', 'char *',\n                            'char *'],\n  'server-modifydn-done': ['int', 'char *', 'char *', 'char *', 'int',\n                           'char *'],\n\n  // 4: scope, 5: filter\n  'server-search-start': ['int', 'char *', 'char *', 'char *', 'char *',\n                          'char *'],\n  'server-search-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n  // Last two are searchEntry.DN and seachEntry.attributes.length\n  'server-search-entry': ['int', 'char *', 'char *', 'char *', 'char *', 'int'],\n\n  'server-unbind-start': ['int', 'char *', 'char *', 'char *'],\n  'server-unbind-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  'server-abandon-start': ['int', 'char *', 'char *', 'char *'],\n  'server-abandon-done': ['int', 'char *', 'char *', 'char *', 'int', 'char *'],\n\n  // remote IP\n  'server-connection': ['char *']\n};\n\n\n///--- API\n\nmodule.exports = function () {\n  if (!SERVER_PROVIDER) {\n    try {\n      var dtrace = require('dtrace-provider');\n      SERVER_PROVIDER = dtrace.createDTraceProvider('ldapjs');\n\n      Object.keys(SERVER_PROBES).forEach(function (p) {\n        var args = SERVER_PROBES[p].splice(0);\n        args.unshift(p);\n\n        dtrace.DTraceProvider.prototype.addProbe.apply(SERVER_PROVIDER, args);\n      });\n    } catch (e) {\n      SERVER_PROVIDER = {\n          fire: function () {\n          },\n          enable: function () {\n          },\n          addProbe: function () {\n              var p = {\n                  fire: function () {\n                  }\n              };\n              return (p);\n          },\n          removeProbe: function () {\n          },\n          disable: function () {\n          }\n      };\n    }\n\n    SERVER_PROVIDER.enable();\n\n    SERVER_PROVIDER._nextId = function () {\n      if (DTRACE_ID === MAX_INT)\n        DTRACE_ID = 0;\n\n      return ++DTRACE_ID;\n    };\n  }\n\n  return SERVER_PROVIDER;\n}();\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/parser.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar VError = require('verror').VError;\n\nvar AbandonRequest = require('./abandon_request');\nvar AddRequest = require('./add_request');\nvar AddResponse = require('./add_response');\nvar BindRequest = require('./bind_request');\nvar BindResponse = require('./bind_response');\nvar CompareRequest = require('./compare_request');\nvar CompareResponse = require('./compare_response');\nvar DeleteRequest = require('./del_request');\nvar DeleteResponse = require('./del_response');\nvar ExtendedRequest = require('./ext_request');\nvar ExtendedResponse = require('./ext_response');\nvar ModifyRequest = require('./modify_request');\nvar ModifyResponse = require('./modify_response');\nvar ModifyDNRequest = require('./moddn_request');\nvar ModifyDNResponse = require('./moddn_response');\nvar SearchRequest = require('./search_request');\nvar SearchEntry = require('./search_entry');\nvar SearchReference = require('./search_reference');\nvar SearchResponse = require('./search_response');\nvar UnbindRequest = require('./unbind_request');\nvar UnbindResponse = require('./unbind_response');\n\nvar LDAPResult = require('./result');\nvar Message = require('./message');\n\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\nvar BerReader = asn1.BerReader;\n\n\n///--- API\n\nfunction Parser(options) {\n  assert.object(options);\n  assert.object(options.log);\n\n  EventEmitter.call(this);\n\n  this.buffer = null;\n  this.log = options.log;\n}\nutil.inherits(Parser, EventEmitter);\n\nParser.prototype.write = function (data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data (buffer) required');\n\n  var nextMessage = null;\n  var self = this;\n\n  function end() {\n    if (nextMessage)\n      return self.write(nextMessage);\n\n    return true;\n  }\n\n  self.buffer = (self.buffer ? Buffer.concat([self.buffer, data]) : data);\n\n  var ber = new BerReader(self.buffer);\n\n  var foundSeq = false;\n  try {\n    foundSeq = ber.readSequence();\n  } catch (e) {\n    this.emit('error', e);\n  }\n\n  if (!foundSeq || ber.remain < ber.length) {\n    // ENOTENOUGH\n    return false;\n  } else if (ber.remain > ber.length) {\n    // ETOOMUCH\n    // This is sort of ugly, but allows us to make miminal copies\n    nextMessage = self.buffer.slice(ber.offset + ber.length);\n    ber._size = ber.offset + ber.length;\n    assert.equal(ber.remain, ber.length);\n  }\n\n  // If we're here, ber holds the message, and nextMessage is temporarily\n  // pointing at the next sequence of data (if it exists)\n  self.buffer = null;\n\n  var message;\n  try {\n    // Bail here if peer isn't speaking protocol at all\n    message = this.getMessage(ber);\n\n    if (!message) {\n      return end();\n    }\n    message.parse(ber);\n  } catch (e) {\n    this.emit('error', e, message);\n    return false;\n  }\n\n  this.emit('message', message);\n  return end();\n};\n\nParser.prototype.getMessage = function (ber) {\n  assert.ok(ber);\n\n  var self = this;\n\n  var messageID = ber.readInt();\n  var type = ber.readSequence();\n\n  var Message;\n  switch (type) {\n\n  case Protocol.LDAP_REQ_ABANDON:\n    Message = AbandonRequest;\n    break;\n\n  case Protocol.LDAP_REQ_ADD:\n    Message = AddRequest;\n    break;\n\n  case Protocol.LDAP_REP_ADD:\n    Message = AddResponse;\n    break;\n\n  case Protocol.LDAP_REQ_BIND:\n    Message = BindRequest;\n    break;\n\n  case Protocol.LDAP_REP_BIND:\n    Message = BindResponse;\n    break;\n\n  case Protocol.LDAP_REQ_COMPARE:\n    Message = CompareRequest;\n    break;\n\n  case Protocol.LDAP_REP_COMPARE:\n    Message = CompareResponse;\n    break;\n\n  case Protocol.LDAP_REQ_DELETE:\n    Message = DeleteRequest;\n    break;\n\n  case Protocol.LDAP_REP_DELETE:\n    Message = DeleteResponse;\n    break;\n\n  case Protocol.LDAP_REQ_EXTENSION:\n    Message = ExtendedRequest;\n    break;\n\n  case Protocol.LDAP_REP_EXTENSION:\n    Message = ExtendedResponse;\n    break;\n\n  case Protocol.LDAP_REQ_MODIFY:\n    Message = ModifyRequest;\n    break;\n\n  case Protocol.LDAP_REP_MODIFY:\n    Message = ModifyResponse;\n    break;\n\n  case Protocol.LDAP_REQ_MODRDN:\n    Message = ModifyDNRequest;\n    break;\n\n  case Protocol.LDAP_REP_MODRDN:\n    Message = ModifyDNResponse;\n    break;\n\n  case Protocol.LDAP_REQ_SEARCH:\n    Message = SearchRequest;\n    break;\n\n  case Protocol.LDAP_REP_SEARCH_ENTRY:\n    Message = SearchEntry;\n    break;\n\n  case Protocol.LDAP_REP_SEARCH_REF:\n    Message = SearchReference;\n    break;\n\n  case Protocol.LDAP_REP_SEARCH:\n    Message = SearchResponse;\n    break;\n\n  case Protocol.LDAP_REQ_UNBIND:\n    Message = UnbindRequest;\n    break;\n\n  default:\n    this.emit('error',\n              new Error('Op 0x' + (type ? type.toString(16) : '??') +\n                        ' not supported'),\n              new LDAPResult({\n                messageID: messageID,\n                protocolOp: type || Protocol.LDAP_REP_EXTENSION\n              }));\n\n    return false;\n  }\n\n\n  return new Message({\n    messageID: messageID,\n    log: self.log\n  });\n};\n\n\n///--- Exports\n\nmodule.exports = Parser;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/abandon_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction AbandonRequest(options) {\n  options = options || {};\n  assert.object(options);\n  assert.optionalNumber(options.abandonID);\n\n  options.protocolOp = Protocol.LDAP_REQ_ABANDON;\n  LDAPMessage.call(this, options);\n\n  this.abandonID = options.abandonID || 0;\n}\nutil.inherits(AbandonRequest, LDAPMessage);\nObject.defineProperties(AbandonRequest.prototype, {\n  type: {\n    get: function getType() { return 'AbandonRequest'; },\n    configurable: false\n  }\n});\n\nAbandonRequest.prototype._parse = function (ber, length) {\n  assert.ok(ber);\n  assert.ok(length);\n\n  // What a PITA - have to replicate ASN.1 integer logic to work around the\n  // way abandon is encoded and the way ldapjs framework handles \"normal\"\n  // messages\n\n  var buf = ber.buffer;\n  var offset = 0;\n  var value = 0;\n\n  var fb = buf[offset++];\n  value = fb & 0x7F;\n  for (var i = 1; i < length; i++) {\n    value <<= 8;\n    value |= (buf[offset++] & 0xff);\n  }\n  if ((fb & 0x80) == 0x80)\n    value = -value;\n\n  ber._offset += length;\n\n  this.abandonID = value;\n\n  return true;\n};\n\nAbandonRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  var i = this.abandonID;\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&\n         (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n  assert.ok(sz <= 4);\n\n  while (sz-- > 0) {\n    ber.writeByte((i & 0xff000000) >> 24);\n    i <<= 8;\n  }\n\n  return ber;\n};\n\nAbandonRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.abandonID = this.abandonID;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = AbandonRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/add_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Attribute = require('../attribute');\nvar Protocol = require('../protocol');\nvar lassert = require('../assert');\n\n\n///--- API\n\nfunction AddRequest(options) {\n  options = options || {};\n  assert.object(options);\n  lassert.optionalStringDN(options.entry);\n  lassert.optionalArrayOfAttribute(options.attributes);\n\n  options.protocolOp = Protocol.LDAP_REQ_ADD;\n  LDAPMessage.call(this, options);\n\n  this.entry = options.entry || null;\n  this.attributes = options.attributes ? options.attributes.slice(0) : [];\n}\nutil.inherits(AddRequest, LDAPMessage);\nObject.defineProperties(AddRequest.prototype, {\n  type: {\n    get: function getType() { return 'AddRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.entry; },\n    configurable: false\n  }\n});\n\nAddRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.entry = ber.readString();\n\n  ber.readSequence();\n\n  var end = ber.offset + ber.length;\n  while (ber.offset < end) {\n    var a = new Attribute();\n    a.parse(ber);\n    a.type = a.type.toLowerCase();\n    if (a.type === 'objectclass') {\n      for (var i = 0; i < a.vals.length; i++)\n        a.vals[i] = a.vals[i].toLowerCase();\n    }\n    this.attributes.push(a);\n  }\n\n  this.attributes.sort(Attribute.compare);\n  return true;\n};\n\nAddRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.entry.toString());\n  ber.startSequence();\n  this.attributes.forEach(function (a) {\n    a.toBer(ber);\n  });\n  ber.endSequence();\n\n  return ber;\n};\n\nAddRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.entry = this.entry.toString();\n  j.attributes = [];\n\n  this.attributes.forEach(function (a) {\n    j.attributes.push(a.json);\n  });\n\n  return j;\n};\n\nAddRequest.prototype.indexOf = function (attr) {\n  if (!attr || typeof (attr) !== 'string')\n    throw new TypeError('attr (string) required');\n\n  for (var i = 0; i < this.attributes.length; i++) {\n    if (this.attributes[i].type === attr)\n      return i;\n  }\n\n  return -1;\n};\n\nAddRequest.prototype.attributeNames = function () {\n  var attrs = [];\n\n  for (var i = 0; i < this.attributes.length; i++)\n    attrs.push(this.attributes[i].type.toLowerCase());\n\n  return attrs;\n};\n\nAddRequest.prototype.getAttribute = function (name) {\n  if (!name || typeof (name) !== 'string')\n    throw new TypeError('attribute name (string) required');\n\n  name = name.toLowerCase();\n\n  for (var i = 0; i < this.attributes.length; i++) {\n    if (this.attributes[i].type === name)\n      return this.attributes[i];\n  }\n\n  return null;\n};\n\nAddRequest.prototype.addAttribute = function (attr) {\n  if (!(attr instanceof Attribute))\n    throw new TypeError('attribute (Attribute) required');\n\n  return this.attributes.push(attr);\n};\n\n/**\n * Returns a \"pure\" JS representation of this object.\n *\n * An example object would look like:\n *\n * {\n *   \"dn\": \"cn=unit, dc=test\",\n *   \"attributes\": {\n *     \"cn\": [\"unit\", \"foo\"],\n *     \"objectclass\": [\"top\", \"person\"]\n *   }\n * }\n *\n * @return {Object} that looks like the above.\n */\nAddRequest.prototype.toObject = function () {\n  var self = this;\n\n  var obj = {\n    dn: self.entry ? self.entry.toString() : '',\n    attributes: {}\n  };\n\n  if (!this.attributes || !this.attributes.length)\n    return obj;\n\n  this.attributes.forEach(function (a) {\n    if (!obj.attributes[a.type])\n      obj.attributes[a.type] = [];\n\n    a.vals.forEach(function (v) {\n      if (obj.attributes[a.type].indexOf(v) === -1)\n        obj.attributes[a.type].push(v);\n    });\n  });\n\n  return obj;\n};\n\n\n///--- Exports\n\nmodule.exports = AddRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/assert.js":"// Copyright 2015 Joyent, Inc.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar isDN = require('./dn').DN.isDN;\nvar isAttribute = require('./attribute').isAttribute;\n\n\n///--- Helpers\n\n// Copied from mcavage/node-assert-plus\nfunction _assert(arg, type, name) {\n  name = name || type;\n  throw new assert.AssertionError({\n    message: util.format('%s (%s) required', name, type),\n    actual: typeof (arg),\n    expected: type,\n    operator: '===',\n    stackStartFunction: _assert.caller\n  });\n}\n\n\n///--- API\n\nfunction stringDN(input, name) {\n  if (isDN(input) || typeof (input) === 'string')\n    return;\n  _assert(input, 'DN or string', name);\n}\n\nfunction optionalStringDN(input, name) {\n  if (input === undefined || isDN(input) || typeof (input) === 'string')\n    return;\n  _assert(input, 'DN or string', name);\n}\n\nfunction optionalDN(input, name) {\n  if (input !== undefined && !isDN(input))\n    _assert(input, 'DN', name);\n}\n\nfunction optionalArrayOfAttribute(input, name) {\n  if (input === undefined)\n    return;\n  if (!Array.isArray(input) ||\n      input.some(function (v) { return !isAttribute(v); })) {\n  _assert(input, 'array of Attribute', name);\n  }\n}\n\n\n///--- Exports\n\nmodule.exports = {\n  stringDN: stringDN,\n  optionalStringDN: optionalStringDN,\n  optionalDN: optionalDN,\n  optionalArrayOfAttribute: optionalArrayOfAttribute\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/add_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction AddResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_ADD;\n  LDAPResult.call(this, options);\n}\nutil.inherits(AddResponse, LDAPResult);\n\n\n///--- Exports\n\nmodule.exports = AddResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/bind_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\nvar LDAP_BIND_SIMPLE = 'simple';\nvar LDAP_BIND_SASL = 'sasl';\n\n\n///--- API\n\nfunction BindRequest(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REQ_BIND;\n  LDAPMessage.call(this, options);\n\n  this.version = options.version || 0x03;\n  this.name = options.name || null;\n  this.authentication = options.authentication || LDAP_BIND_SIMPLE;\n  this.credentials = options.credentials || '';\n}\nutil.inherits(BindRequest, LDAPMessage);\nObject.defineProperties(BindRequest.prototype, {\n  type: {\n    get: function getType() { return 'BindRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.name; },\n    configurable: false\n  }\n});\n\nBindRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.version = ber.readInt();\n  this.name = ber.readString();\n\n  var t = ber.peek();\n\n  // TODO add support for SASL et al\n  if (t !== Ber.Context)\n    throw new Error('authentication 0x' + t.toString(16) + ' not supported');\n\n  this.authentication = LDAP_BIND_SIMPLE;\n  this.credentials = ber.readString(Ber.Context);\n\n  return true;\n};\n\nBindRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeInt(this.version);\n  ber.writeString((this.name || '').toString());\n  // TODO add support for SASL et al\n  ber.writeString((this.credentials || ''), Ber.Context);\n\n  return ber;\n};\n\nBindRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.version = this.version;\n  j.name = this.name;\n  j.authenticationType = this.authentication;\n  j.credentials = this.credentials;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = BindRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/bind_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction BindResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_BIND;\n  LDAPResult.call(this, options);\n}\nutil.inherits(BindResponse, LDAPResult);\n\n\n///--- Exports\n\nmodule.exports = BindResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/compare_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\nvar lassert = require('../assert');\n\n\n///--- API\n\nfunction CompareRequest(options) {\n  options = options || {};\n  assert.object(options);\n  assert.optionalString(options.attribute);\n  assert.optionalString(options.value);\n  lassert.optionalStringDN(options.entry);\n\n  options.protocolOp = Protocol.LDAP_REQ_COMPARE;\n  LDAPMessage.call(this, options);\n\n  this.entry = options.entry || null;\n  this.attribute = options.attribute || '';\n  this.value = options.value || '';\n}\nutil.inherits(CompareRequest, LDAPMessage);\nObject.defineProperties(CompareRequest.prototype, {\n  type: {\n    get: function getType() { return 'CompareRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.entry; },\n    configurable: false\n  }\n});\n\nCompareRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.entry = ber.readString();\n\n  ber.readSequence();\n  this.attribute = ber.readString().toLowerCase();\n  this.value = ber.readString();\n\n  return true;\n};\n\nCompareRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.entry.toString());\n  ber.startSequence();\n  ber.writeString(this.attribute);\n  ber.writeString(this.value);\n  ber.endSequence();\n\n  return ber;\n};\n\nCompareRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.entry = this.entry.toString();\n  j.attribute = this.attribute;\n  j.value = this.value;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = CompareRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/compare_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction CompareResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_COMPARE;\n  LDAPResult.call(this, options);\n}\nutil.inherits(CompareResponse, LDAPResult);\n\nCompareResponse.prototype.end = function (matches) {\n  var status = 0x06;\n  if (typeof (matches) === 'boolean') {\n    if (!matches)\n      status = 0x05; // Compare false\n  } else {\n    status = matches;\n  }\n\n  return LDAPResult.prototype.end.call(this, status);\n};\n\n\n///--- Exports\n\nmodule.exports = CompareResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/del_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\nvar lassert = require('../assert');\n\n\n///--- API\n\nfunction DeleteRequest(options) {\n  options = options || {};\n  assert.object(options);\n  lassert.optionalStringDN(options.entry);\n\n  options.protocolOp = Protocol.LDAP_REQ_DELETE;\n  LDAPMessage.call(this, options);\n\n  this.entry = options.entry || null;\n}\nutil.inherits(DeleteRequest, LDAPMessage);\nObject.defineProperties(DeleteRequest.prototype, {\n  type: {\n    get: function getType() { return 'DeleteRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.entry; },\n    configurable: false\n  }\n});\n\nDeleteRequest.prototype._parse = function (ber, length) {\n  assert.ok(ber);\n\n  this.entry = ber.buffer.slice(0, length).toString('utf8');\n  ber._offset += ber.length;\n\n  return true;\n};\n\nDeleteRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  var buf = new Buffer(this.entry.toString());\n  for (var i = 0; i < buf.length; i++)\n    ber.writeByte(buf[i]);\n\n  return ber;\n};\n\nDeleteRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.entry = this.entry;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = DeleteRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/del_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction DeleteResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_DELETE;\n  LDAPResult.call(this, options);\n}\nutil.inherits(DeleteResponse, LDAPResult);\n\n\n///--- Exports\n\nmodule.exports = DeleteResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/ext_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction ExtendedRequest(options) {\n  options = options || {};\n  assert.object(options);\n  assert.optionalString(options.requestName);\n  if (options.requestValue &&\n      !(Buffer.isBuffer(options.requestValue) ||\n      typeof (options.requestValue) === 'string')) {\n    throw new TypeError('options.requestValue must be a buffer or a string');\n  }\n\n  options.protocolOp = Protocol.LDAP_REQ_EXTENSION;\n  LDAPMessage.call(this, options);\n\n  this.requestName = options.requestName || '';\n  this.requestValue = options.requestValue;\n}\nutil.inherits(ExtendedRequest, LDAPMessage);\nObject.defineProperties(ExtendedRequest.prototype, {\n  type: {\n    get: function getType() { return 'ExtendedRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.requestName; },\n    configurable: false\n  },\n  name: {\n    get: function getName() { return this.requestName; },\n    set: function setName(val) {\n      assert.string(val);\n      this.requestName = val;\n    },\n    configurable: false\n  },\n  value: {\n    get: function getValue() { return this.requestValue; },\n    set: function setValue(val) {\n      if (!(Buffer.isBuffer(val) || typeof (val) === 'string'))\n        throw new TypeError('value must be a buffer or a string');\n\n      this.requestValue = val;\n    },\n    configurable: false\n  }\n});\n\nExtendedRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.requestName = ber.readString(0x80);\n  if (ber.peek() === 0x81)\n    try {\n      this.requestValue = ber.readString(0x81);\n    } catch (e) {\n      this.requestValue = ber.readBuffer(0x81);\n    }\n\n  return true;\n};\n\nExtendedRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.requestName, 0x80);\n  if (Buffer.isBuffer(this.requestValue)) {\n    ber.writeBuffer(this.requestValue, 0x81);\n  } else if (typeof (this.requestValue) === 'string') {\n    ber.writeString(this.requestValue, 0x81);\n  }\n\n  return ber;\n};\n\nExtendedRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.requestName = this.requestName;\n  j.requestValue = (Buffer.isBuffer(this.requestValue)) ?\n    this.requestValue.toString('hex') : this.requestValue;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = ExtendedRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/ext_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction ExtendedResponse(options) {\n  options = options || {};\n  assert.object(options);\n  assert.optionalString(options.responseName);\n  assert.optionalString(options.responsevalue);\n\n  this.responseName = options.responseName || undefined;\n  this.responseValue = options.responseValue || undefined;\n\n  options.protocolOp = Protocol.LDAP_REP_EXTENSION;\n  LDAPResult.call(this, options);\n}\nutil.inherits(ExtendedResponse, LDAPResult);\nObject.defineProperties(ExtendedResponse.prototype, {\n  type: {\n    get: function getType() { return 'ExtendedResponse'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.responseName; },\n    configurable: false\n  },\n  name: {\n    get: function getName() { return this.responseName; },\n    set: function setName(val) {\n      assert.string(val);\n      this.responseName = val;\n    },\n    configurable: false\n  },\n  value: {\n    get: function getValue() { return this.responseValue; },\n    set: function (val) {\n      assert.string(val);\n      this.responseValue = val;\n    },\n    configurable: false\n  }\n});\n\nExtendedResponse.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  if (!LDAPResult.prototype._parse.call(this, ber))\n    return false;\n\n  if (ber.peek() === 0x8a)\n    this.responseName = ber.readString(0x8a);\n  if (ber.peek() === 0x8b)\n    this.responseValue = ber.readString(0x8b);\n\n  return true;\n};\n\nExtendedResponse.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (!LDAPResult.prototype._toBer.call(this, ber))\n    return false;\n\n  if (this.responseName)\n    ber.writeString(this.responseName, 0x8a);\n  if (this.responseValue)\n    ber.writeString(this.responseValue, 0x8b);\n\n  return ber;\n};\n\nExtendedResponse.prototype._json = function (j) {\n  assert.ok(j);\n\n  j = LDAPResult.prototype._json.call(this, j);\n\n  j.responseName = this.responseName;\n  j.responseValue = this.responseValue;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = ExtendedResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/modify_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Change = require('../change');\nvar Protocol = require('../protocol');\nvar lassert = require('../assert');\n\n\n///--- API\n\nfunction ModifyRequest(options) {\n  options = options || {};\n  assert.object(options);\n  lassert.optionalStringDN(options.object);\n  lassert.optionalArrayOfAttribute(options.attributes);\n\n  options.protocolOp = Protocol.LDAP_REQ_MODIFY;\n  LDAPMessage.call(this, options);\n\n  this.object = options.object || null;\n  this.changes = options.changes ? options.changes.slice(0) : [];\n}\nutil.inherits(ModifyRequest, LDAPMessage);\nObject.defineProperties(ModifyRequest.prototype, {\n  type: {\n    get: function getType() { return 'ModifyRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.object; },\n    configurable: false\n  }\n});\n\nModifyRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.object = ber.readString();\n\n  ber.readSequence();\n  var end = ber.offset + ber.length;\n  while (ber.offset < end) {\n    var c = new Change();\n    c.parse(ber);\n    c.modification.type = c.modification.type.toLowerCase();\n    this.changes.push(c);\n  }\n\n  this.changes.sort(Change.compare);\n  return true;\n};\n\nModifyRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.object.toString());\n  ber.startSequence();\n  this.changes.forEach(function (c) {\n    c.toBer(ber);\n  });\n  ber.endSequence();\n\n  return ber;\n};\n\nModifyRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.object = this.object;\n  j.changes = [];\n\n  this.changes.forEach(function (c) {\n    j.changes.push(c.json);\n  });\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = ModifyRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/modify_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction ModifyResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_MODIFY;\n  LDAPResult.call(this, options);\n}\nutil.inherits(ModifyResponse, LDAPResult);\n\n\n///--- Exports\n\nmodule.exports = ModifyResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/moddn_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\nvar dn = require('../dn');\nvar lassert = require('../assert');\n\n\n///--- API\n\nfunction ModifyDNRequest(options) {\n  options = options || {};\n  assert.object(options);\n  assert.optionalBool(options.deleteOldRdn);\n  lassert.optionalStringDN(options.entry);\n  lassert.optionalDN(options.newRdn);\n  lassert.optionalDN(options.newSuperior);\n\n  options.protocolOp = Protocol.LDAP_REQ_MODRDN;\n  LDAPMessage.call(this, options);\n\n  this.entry = options.entry || null;\n  this.newRdn = options.newRdn || null;\n  this.deleteOldRdn = options.deleteOldRdn || true;\n  this.newSuperior = options.newSuperior || null;\n}\nutil.inherits(ModifyDNRequest, LDAPMessage);\nObject.defineProperties(ModifyDNRequest.prototype, {\n  type: {\n    get: function getType() { return 'ModifyDNRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.entry; },\n    configurable: false\n  }\n});\n\nModifyDNRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.entry = ber.readString();\n  this.newRdn = dn.parse(ber.readString());\n  this.deleteOldRdn = ber.readBoolean();\n  if (ber.peek() === 0x80)\n    this.newSuperior = dn.parse(ber.readString(0x80));\n\n  return true;\n};\n\nModifyDNRequest.prototype._toBer = function (ber) {\n  //assert.ok(ber);\n\n  ber.writeString(this.entry.toString());\n  ber.writeString(this.newRdn.toString());\n  ber.writeBoolean(this.deleteOldRdn);\n  if (this.newSuperior) {\n    var s = this.newSuperior.toString();\n    var len = Buffer.byteLength(s);\n\n    ber.writeByte(0x80); // MODIFY_DN_REQUEST_NEW_SUPERIOR_TAG\n    ber.writeByte(len);\n    ber._ensure(len);\n    ber._buf.write(s, ber._offset);\n    ber._offset += len;\n  }\n\n  return ber;\n};\n\nModifyDNRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.entry = this.entry.toString();\n  j.newRdn = this.newRdn.toString();\n  j.deleteOldRdn = this.deleteOldRdn;\n  j.newSuperior = this.newSuperior ? this.newSuperior.toString() : '';\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = ModifyDNRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/moddn_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction ModifyDNResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_MODRDN;\n  LDAPResult.call(this, options);\n}\nutil.inherits(ModifyDNResponse, LDAPResult);\n\n\n///--- Exports\n\nmodule.exports = ModifyDNResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/search_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar LDAPMessage = require('./message');\nvar LDAPResult = require('./result');\nvar dn = require('../dn');\nvar filters = require('../filters');\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\n\n\n///--- API\n\nfunction SearchRequest(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REQ_SEARCH;\n  LDAPMessage.call(this, options);\n\n  if (options.baseObject !== undefined) {\n    this.baseObject = options.baseObject;\n  } else {\n    this.baseObject = dn.parse('');\n  }\n  this.scope = options.scope || 'base';\n  this.derefAliases = options.derefAliases || Protocol.NEVER_DEREF_ALIASES;\n  this.sizeLimit = options.sizeLimit || 0;\n  this.timeLimit = options.timeLimit || 0;\n  this.typesOnly = options.typesOnly || false;\n  this.filter = options.filter || null;\n  this.attributes = options.attributes ? options.attributes.slice(0) : [];\n}\nutil.inherits(SearchRequest, LDAPMessage);\nObject.defineProperties(SearchRequest.prototype, {\n  type: {\n    get: function getType() { return 'SearchRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.baseObject; },\n    configurable: false\n  },\n  scope: {\n    get: function getScope() {\n      switch (this._scope) {\n      case Protocol.SCOPE_BASE_OBJECT: return 'base';\n      case Protocol.SCOPE_ONE_LEVEL: return 'one';\n      case Protocol.SCOPE_SUBTREE: return 'sub';\n      default:\n        throw new Error(this._scope + ' is an invalid search scope');\n      }\n    },\n    set: function setScope(val) {\n      if (typeof (val) === 'string') {\n        switch (val) {\n        case 'base':\n          this._scope = Protocol.SCOPE_BASE_OBJECT;\n          break;\n        case 'one':\n          this._scope = Protocol.SCOPE_ONE_LEVEL;\n          break;\n        case 'sub':\n          this._scope = Protocol.SCOPE_SUBTREE;\n          break;\n        default:\n          throw new Error(val + ' is an invalid search scope');\n        }\n      } else {\n        this._scope = val;\n      }\n    },\n    configurable: false\n  }\n});\n\nSearchRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.baseObject = ber.readString();\n  this.scope = ber.readEnumeration();\n  this.derefAliases = ber.readEnumeration();\n  this.sizeLimit = ber.readInt();\n  this.timeLimit = ber.readInt();\n  this.typesOnly = ber.readBoolean();\n\n  this.filter = filters.parse(ber);\n\n  // look for attributes\n  if (ber.peek() === 0x30) {\n    ber.readSequence();\n    var end = ber.offset + ber.length;\n    while (ber.offset < end)\n      this.attributes.push(ber.readString().toLowerCase());\n  }\n\n  return true;\n};\n\nSearchRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.baseObject.toString());\n  ber.writeEnumeration(this._scope);\n  ber.writeEnumeration(this.derefAliases);\n  ber.writeInt(this.sizeLimit);\n  ber.writeInt(this.timeLimit);\n  ber.writeBoolean(this.typesOnly);\n\n  var f = this.filter || new filters.PresenceFilter({attribute: 'objectclass'});\n  ber = f.toBer(ber);\n\n  ber.startSequence(Ber.Sequence | Ber.Constructor);\n  if (this.attributes && this.attributes.length) {\n    this.attributes.forEach(function (a) {\n      ber.writeString(a);\n    });\n  }\n  ber.endSequence();\n\n  return ber;\n};\n\nSearchRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.baseObject = this.baseObject;\n  j.scope = this.scope;\n  j.derefAliases = this.derefAliases;\n  j.sizeLimit = this.sizeLimit;\n  j.timeLimit = this.timeLimit;\n  j.typesOnly = this.typesOnly;\n  j.filter = this.filter.toString();\n  j.attributes = this.attributes;\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = SearchRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/index.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\n\nvar asn1 = require('asn1');\n\nvar parents = require('ldap-filter');\n\nvar Protocol = require('../protocol');\n\nvar Filter = require('./filter');\nvar AndFilter = require('./and_filter');\nvar ApproximateFilter = require('./approx_filter');\nvar EqualityFilter = require('./equality_filter');\nvar ExtensibleFilter = require('./ext_filter');\nvar GreaterThanEqualsFilter = require('./ge_filter');\nvar LessThanEqualsFilter = require('./le_filter');\nvar NotFilter = require('./not_filter');\nvar OrFilter = require('./or_filter');\nvar PresenceFilter = require('./presence_filter');\nvar SubstringFilter = require('./substr_filter');\n\n\n\n///--- Globals\n\nvar BerReader = asn1.BerReader;\n\n\n///--- Internal Parsers\n\n/*\n * A filter looks like this coming in:\n *      Filter ::= CHOICE {\n *              and             [0]     SET OF Filter,\n *              or              [1]     SET OF Filter,\n *              not             [2]     Filter,\n *              equalityMatch   [3]     AttributeValueAssertion,\n *              substrings      [4]     SubstringFilter,\n *              greaterOrEqual  [5]     AttributeValueAssertion,\n *              lessOrEqual     [6]     AttributeValueAssertion,\n *              present         [7]     AttributeType,\n *              approxMatch     [8]     AttributeValueAssertion,\n *              extensibleMatch [9]     MatchingRuleAssertion --v3 only\n *      }\n *\n *      SubstringFilter ::= SEQUENCE {\n *              type               AttributeType,\n *              SEQUENCE OF CHOICE {\n *                      initial          [0] IA5String,\n *                      any              [1] IA5String,\n *                      final            [2] IA5String\n *              }\n *      }\n *\n * The extensibleMatch was added in LDAPv3:\n *\n *      MatchingRuleAssertion ::= SEQUENCE {\n *              matchingRule    [1] MatchingRuleID OPTIONAL,\n *              type            [2] AttributeDescription OPTIONAL,\n *              matchValue      [3] AssertionValue,\n *              dnAttributes    [4] BOOLEAN DEFAULT FALSE\n *      }\n */\nfunction _parse(ber) {\n  assert.ok(ber);\n\n  function parseSet(f) {\n    var end = ber.offset + ber.length;\n    while (ber.offset < end)\n      f.addFilter(_parse(ber));\n  }\n\n  var f;\n\n  var type = ber.readSequence();\n  switch (type) {\n\n  case Protocol.FILTER_AND:\n    f = new AndFilter();\n    parseSet(f);\n    break;\n\n  case Protocol.FILTER_APPROX:\n    f = new ApproximateFilter();\n    f.parse(ber);\n    break;\n\n  case Protocol.FILTER_EQUALITY:\n    f = new EqualityFilter();\n    f.parse(ber);\n    return f;\n\n  case Protocol.FILTER_EXT:\n    f = new ExtensibleFilter();\n    f.parse(ber);\n    return f;\n\n  case Protocol.FILTER_GE:\n    f = new GreaterThanEqualsFilter();\n    f.parse(ber);\n    return f;\n\n  case Protocol.FILTER_LE:\n    f = new LessThanEqualsFilter();\n    f.parse(ber);\n    return f;\n\n  case Protocol.FILTER_NOT:\n    var _f = _parse(ber);\n    f = new NotFilter({\n      filter: _f\n    });\n    break;\n\n  case Protocol.FILTER_OR:\n    f = new OrFilter();\n    parseSet(f);\n    break;\n\n  case Protocol.FILTER_PRESENT:\n    f = new PresenceFilter();\n    f.parse(ber);\n    break;\n\n  case Protocol.FILTER_SUBSTRINGS:\n    f = new SubstringFilter();\n    f.parse(ber);\n    break;\n\n  default:\n    throw new Error('Invalid search filter type: 0x' + type.toString(16));\n  }\n\n\n  assert.ok(f);\n  return f;\n}\n\n\nfunction cloneFilter(input) {\n  var child;\n  if (input.type === 'and' || input.type === 'or') {\n    child = input.filters.map(cloneFilter);\n  } else if (input.type === 'not') {\n    child = cloneFilter(input.filter);\n  }\n  switch (input.type) {\n  case 'and':\n    return new AndFilter({filters: child});\n  case 'or':\n    return new OrFilter({filters: child});\n  case 'not':\n    return new NotFilter({filter: child});\n  case 'equal':\n    return new EqualityFilter(input);\n  case 'substring':\n    return new SubstringFilter(input);\n  case 'ge':\n    return new GreaterThanEqualsFilter(input);\n  case 'le':\n    return new LessThanEqualsFilter(input);\n  case 'present':\n    return new PresenceFilter(input);\n  case 'approx':\n    return new ApproximateFilter(input);\n  case 'ext':\n    return new ExtensibleFilter(input);\n  default:\n    throw new Error('invalid filter type:' + input.type);\n  }\n}\n\n\nfunction parseString(str) {\n  var generic = parents.parse(str);\n  // The filter object(s) return from ldap-filter.parse lack the toBer/parse\n  // decoration that native ldapjs filter possess.  cloneFilter adds that back.\n  return cloneFilter(generic);\n}\n\n\n///--- API\n\nmodule.exports = {\n  parse: function (ber) {\n    if (!ber || !(ber instanceof BerReader))\n      throw new TypeError('ber (BerReader) required');\n\n    return _parse(ber);\n  },\n\n  parseString: parseString,\n\n  isFilter: Filter.isFilter,\n\n  AndFilter: AndFilter,\n  ApproximateFilter: ApproximateFilter,\n  EqualityFilter: EqualityFilter,\n  ExtensibleFilter: ExtensibleFilter,\n  GreaterThanEqualsFilter: GreaterThanEqualsFilter,\n  LessThanEqualsFilter: LessThanEqualsFilter,\n  NotFilter: NotFilter,\n  OrFilter: OrFilter,\n  PresenceFilter: PresenceFilter,\n  SubstringFilter: SubstringFilter\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\n\nvar asn1 = require('asn1');\n\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar BerWriter = asn1.BerWriter;\n\nvar TYPES = {\n  'and':       Protocol.FILTER_AND,\n  'or':        Protocol.FILTER_OR,\n  'not':       Protocol.FILTER_NOT,\n  'equal':     Protocol.FILTER_EQUALITY,\n  'substring': Protocol.FILTER_SUBSTRINGS,\n  'ge':        Protocol.FILTER_GE,\n  'le':        Protocol.FILTER_LE,\n  'present':   Protocol.FILTER_PRESENT,\n  'approx':    Protocol.FILTER_APPROX,\n  'ext':       Protocol.FILTER_EXT\n};\n\n\n///--- API\n\nfunction isFilter(filter) {\n  if (!filter || typeof (filter) !== 'object') {\n    return false;\n  }\n  // Do our best to duck-type it\n  if (typeof (filter.toBer) === 'function' &&\n      typeof (filter.matches) === 'function' &&\n      TYPES[filter.type] !== undefined) {\n    return true;\n  }\n  return false;\n}\n\nfunction mixin(target) {\n  target.prototype.toBer = function toBer(ber) {\n    if (!ber || !(ber instanceof BerWriter))\n      throw new TypeError('ber (BerWriter) required');\n\n    ber.startSequence(TYPES[this.type]);\n    ber = this._toBer(ber);\n    ber.endSequence();\n    return ber;\n  };\n}\n\nmodule.exports = {\n  isFilter: isFilter,\n  mixin: mixin\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/and_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n\n///--- API\n\nfunction AndFilter(options) {\n  parents.AndFilter.call(this, options);\n}\nutil.inherits(AndFilter, parents.AndFilter);\nFilter.mixin(AndFilter);\nmodule.exports = AndFilter;\n\n\nAndFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  this.filters.forEach(function (f) {\n    ber = f.toBer(ber);\n  });\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/approx_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n\n///--- API\n\nfunction ApproximateFilter(options) {\n  parents.ApproximateFilter.call(this, options);\n}\nutil.inherits(ApproximateFilter, parents.ApproximateFilter);\nFilter.mixin(ApproximateFilter);\nmodule.exports = ApproximateFilter;\n\n\nApproximateFilter.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  this.attribute = ber.readString().toLowerCase();\n  this.value = ber.readString();\n\n  return true;\n};\n\n\nApproximateFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.attribute);\n  ber.writeString(this.value);\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/equality_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar ASN1 = require('asn1').Ber;\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n\n///--- API\n\nfunction EqualityFilter(options) {\n  parents.EqualityFilter.call(this, options);\n}\nutil.inherits(EqualityFilter, parents.EqualityFilter);\nFilter.mixin(EqualityFilter);\nmodule.exports = EqualityFilter;\n\n\nEqualityFilter.prototype.matches = function (target, strictAttrCase) {\n  assert.object(target, 'target');\n\n  var tv = parents.getAttrValue(target, this.attribute, strictAttrCase);\n  var value = this.value;\n\n  if (this.attribute.toLowerCase() === 'objectclass') {\n    /*\n     * Perform case-insensitive match for objectClass since nearly every LDAP\n     * implementation behaves in this manner.\n     */\n    value = value.toLowerCase();\n    return parents.testValues(function (v) {\n      return value === v.toLowerCase();\n    }, tv);\n  } else {\n    return parents.testValues(function (v) {\n      return value === v;\n    }, tv);\n  }\n};\n\n\nEqualityFilter.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  this.attribute = ber.readString().toLowerCase();\n  this.value = ber.readString(ASN1.OctetString, true);\n\n  if (this.attribute === 'objectclass')\n    this.value = this.value.toLowerCase();\n\n  return true;\n};\n\n\nEqualityFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.attribute);\n  ber.writeBuffer(this.raw, ASN1.OctetString);\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/ext_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n\n// THIS IS A STUB!\n//\n// ldapjs does not support server side extensible matching.\n// This class exists only for the client to send them.\n\n///--- API\n\nfunction ExtensibleFilter(options) {\n  parents.ExtensibleFilter.call(this, options);\n}\nutil.inherits(ExtensibleFilter, parents.ExtensibleFilter);\nFilter.mixin(ExtensibleFilter);\nmodule.exports = ExtensibleFilter;\n\n\nExtensibleFilter.prototype.parse = function (ber) {\n  var end = ber.offset + ber.length;\n  while (ber.offset < end) {\n    var tag = ber.peek();\n    switch (tag) {\n    case 0x81:\n      this.rule = ber.readString(tag);\n      break;\n    case 0x82:\n      this.matchType = ber.readString(tag);\n      break;\n    case 0x83:\n      this.value = ber.readString(tag);\n      break;\n    case 0x84:\n      this.dnAttributes = ber.readBoolean(tag);\n      break;\n    default:\n      throw new Error('Invalid ext_match filter type: 0x' + tag.toString(16));\n    }\n  }\n\n  return true;\n};\n\n\nExtensibleFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  if (this.rule)\n    ber.writeString(this.rule, 0x81);\n  if (this.matchType)\n    ber.writeString(this.matchType, 0x82);\n\n  ber.writeString(this.value, 0x83);\n  if (this.dnAttributes)\n    ber.writeBoolean(this.dnAttributes, 0x84);\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/ge_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n///--- API\n\nfunction GreaterThanEqualsFilter(options) {\n  parents.GreaterThanEqualsFilter.call(this, options);\n}\nutil.inherits(GreaterThanEqualsFilter, parents.GreaterThanEqualsFilter);\nFilter.mixin(GreaterThanEqualsFilter);\nmodule.exports = GreaterThanEqualsFilter;\n\n\nGreaterThanEqualsFilter.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  this.attribute = ber.readString().toLowerCase();\n  this.value = ber.readString();\n\n  return true;\n};\n\n\nGreaterThanEqualsFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.attribute);\n  ber.writeString(this.value);\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/le_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n///--- API\n\nfunction LessThanEqualsFilter(options) {\n  parents.LessThanEqualsFilter.call(this, options);\n}\nutil.inherits(LessThanEqualsFilter, parents.LessThanEqualsFilter);\nFilter.mixin(LessThanEqualsFilter);\nmodule.exports = LessThanEqualsFilter;\n\n\nLessThanEqualsFilter.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  this.attribute = ber.readString().toLowerCase();\n  this.value = ber.readString();\n\n  return true;\n};\n\n\nLessThanEqualsFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.attribute);\n  ber.writeString(this.value);\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/not_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n///--- API\n\nfunction NotFilter(options) {\n  parents.NotFilter.call(this, options);\n}\nutil.inherits(NotFilter, parents.NotFilter);\nFilter.mixin(NotFilter);\nmodule.exports = NotFilter;\n\n\nNotFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  return this.filter.toBer(ber);\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/or_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n///--- API\n\nfunction OrFilter(options) {\n  parents.OrFilter.call(this, options);\n}\nutil.inherits(OrFilter, parents.OrFilter);\nFilter.mixin(OrFilter);\nmodule.exports = OrFilter;\n\n\nOrFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  this.filters.forEach(function (f) {\n    ber = f.toBer(ber);\n  });\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/presence_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n///--- API\n\nfunction PresenceFilter(options) {\n  parents.PresenceFilter.call(this, options);\n}\nutil.inherits(PresenceFilter, parents.PresenceFilter);\nFilter.mixin(PresenceFilter);\nmodule.exports = PresenceFilter;\n\n\nPresenceFilter.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  this.attribute =\n    ber.buffer.slice(0, ber.length).toString('utf8').toLowerCase();\n\n  ber._offset += ber.length;\n\n  return true;\n};\n\n\nPresenceFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  for (var i = 0; i < this.attribute.length; i++)\n    ber.writeByte(this.attribute.charCodeAt(i));\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/substr_filter.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar util = require('util');\n\nvar parents = require('ldap-filter');\n\nvar Filter = require('./filter');\n\n\n///--- API\n\nfunction SubstringFilter(options) {\n  parents.SubstringFilter.call(this, options);\n}\nutil.inherits(SubstringFilter, parents.SubstringFilter);\nFilter.mixin(SubstringFilter);\nmodule.exports = SubstringFilter;\n\n\nSubstringFilter.prototype.parse = function (ber) {\n  assert.ok(ber);\n\n  this.attribute = ber.readString().toLowerCase();\n  ber.readSequence();\n  var end = ber.offset + ber.length;\n\n  while (ber.offset < end) {\n    var tag = ber.peek();\n    switch (tag) {\n    case 0x80: // Initial\n      this.initial = ber.readString(tag);\n      if (this.attribute === 'objectclass')\n        this.initial = this.initial.toLowerCase();\n      break;\n    case 0x81: // Any\n      var anyVal = ber.readString(tag);\n      if (this.attribute === 'objectclass')\n        anyVal = anyVal.toLowerCase();\n      this.any.push(anyVal);\n      break;\n    case 0x82: // Final\n      this.final = ber.readString(tag);\n      if (this.attribute === 'objectclass')\n        this.final = this.final.toLowerCase();\n      break;\n    default:\n      throw new Error('Invalid substrings filter type: 0x' + tag.toString(16));\n    }\n  }\n\n  return true;\n};\n\n\nSubstringFilter.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.attribute);\n  ber.startSequence();\n\n  if (this.initial)\n    ber.writeString(this.initial, 0x80);\n\n  if (this.any && this.any.length)\n    this.any.forEach(function (s) {\n      ber.writeString(s, 0x81);\n    });\n\n  if (this.final)\n    ber.writeString(this.final, 0x82);\n\n  ber.endSequence();\n\n  return ber;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/search_entry.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar LDAPMessage = require('./message');\nvar Attribute = require('../attribute');\nvar Protocol = require('../protocol');\nvar lassert = require('../assert');\n\n\n///--- Globals\n\nvar BerWriter = asn1.BerWriter;\n\n\n///--- API\n\nfunction SearchEntry(options) {\n  options = options || {};\n  assert.object(options);\n  lassert.optionalStringDN(options.objectName);\n\n  options.protocolOp = Protocol.LDAP_REP_SEARCH_ENTRY;\n  LDAPMessage.call(this, options);\n\n  this.objectName = options.objectName || null;\n  this.setAttributes(options.attributes || []);\n}\nutil.inherits(SearchEntry, LDAPMessage);\nObject.defineProperties(SearchEntry.prototype, {\n  type: {\n    get: function getType() { return 'SearchEntry'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return this.objectName; },\n    configurable: false\n  },\n  object: {\n    get: function getObject() {\n      var obj = {\n        dn: this.dn.toString(),\n        controls: []\n      };\n      this.attributes.forEach(function (a) {\n        if (a.vals && a.vals.length) {\n          if (a.vals.length > 1) {\n            obj[a.type] = a.vals.slice();\n          } else {\n            obj[a.type] = a.vals[0];\n          }\n        } else {\n          obj[a.type] = [];\n        }\n      });\n      this.controls.forEach(function (element, index, array) {\n        obj.controls.push(element.json);\n      });\n      return obj;\n    },\n    configurable: false\n  },\n  raw: {\n    get: function getRaw() {\n      var obj = {\n        dn: this.dn.toString(),\n        controls: []\n      };\n\n      this.attributes.forEach(function (a) {\n        if (a.buffers && a.buffers.length) {\n          if (a.buffers.length > 1) {\n            obj[a.type] = a.buffers.slice();\n          } else {\n            obj[a.type] = a.buffers[0];\n          }\n        } else {\n          obj[a.type] = [];\n        }\n          });\n      this.controls.forEach(function (element, index, array) {\n        obj.controls.push(element.json);\n      });\n      return obj;\n    },\n    configurable: false\n  }\n});\n\nSearchEntry.prototype.addAttribute = function (attr) {\n  if (!attr || typeof (attr) !== 'object')\n    throw new TypeError('attr (attribute) required');\n\n  this.attributes.push(attr);\n};\n\nSearchEntry.prototype.toObject = function () {\n  return this.object;\n};\n\nSearchEntry.prototype.fromObject = function (obj) {\n  if (typeof (obj) !== 'object')\n    throw new TypeError('object required');\n\n  var self = this;\n  if (obj.controls)\n    this.controls = obj.controls;\n\n  if (obj.attributes)\n    obj = obj.attributes;\n  this.attributes = [];\n\n  Object.keys(obj).forEach(function (k) {\n    self.attributes.push(new Attribute({type: k, vals: obj[k]}));\n  });\n\n  return true;\n};\n\nSearchEntry.prototype.setAttributes = function (obj) {\n  if (typeof (obj) !== 'object')\n    throw new TypeError('object required');\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (a) {\n      if (!Attribute.isAttribute(a))\n        throw new TypeError('entry must be an Array of Attributes');\n    });\n    this.attributes = obj;\n  } else {\n    var self = this;\n\n    self.attributes = [];\n    Object.keys(obj).forEach(function (k) {\n      var attr = new Attribute({type: k});\n      if (Array.isArray(obj[k])) {\n        obj[k].forEach(function (v) {\n          attr.addValue(v.toString());\n        });\n      } else {\n        attr.addValue(obj[k].toString());\n      }\n      self.attributes.push(attr);\n    });\n  }\n};\n\nSearchEntry.prototype._json = function (j) {\n  assert.ok(j);\n\n  j.objectName = this.objectName.toString();\n  j.attributes = [];\n  this.attributes.forEach(function (a) {\n    j.attributes.push(a.json || a);\n  });\n\n  return j;\n};\n\nSearchEntry.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  this.objectName = ber.readString();\n  assert.ok(ber.readSequence());\n\n  var end = ber.offset + ber.length;\n  while (ber.offset < end) {\n    var a = new Attribute();\n    a.parse(ber);\n    this.attributes.push(a);\n  }\n\n  return true;\n};\n\nSearchEntry.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  ber.writeString(this.objectName.toString());\n  ber.startSequence();\n  this.attributes.forEach(function (a) {\n    // This may or may not be an attribute\n    ber = Attribute.toBer(a, ber);\n  });\n  ber.endSequence();\n\n  return ber;\n};\n\n\n///--- Exports\n\nmodule.exports = SearchEntry;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/search_reference.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar LDAPMessage = require('./message');\nvar Protocol = require('../protocol');\nvar dn = require('../dn');\nvar url = require('../url');\n\n\n///--- Globals\n\nvar BerWriter = asn1.BerWriter;\nvar parseURL = url.parse;\n\n\n///--- API\n\nfunction SearchReference(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_SEARCH_REF;\n  LDAPMessage.call(this, options);\n\n  this.uris = options.uris || [];\n}\nutil.inherits(SearchReference, LDAPMessage);\nObject.defineProperties(SearchReference.prototype, {\n  type: {\n    get: function getType() { return 'SearchReference'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() { return new dn.DN(''); },\n    configurable: false\n  },\n  object: {\n    get: function getObject() {\n      return {\n        dn: this.dn.toString(),\n        uris: this.uris.slice()\n      };\n    },\n    configurable: false\n  },\n  urls: {\n    get: function getUrls() { return this.uris; },\n    set: function setUrls(val) {\n      assert.ok(val);\n      assert.ok(Array.isArray(val));\n      this.uris = val.slice();\n    },\n    configurable: false\n  }\n});\n\nSearchReference.prototype.toObject = function () {\n  return this.object;\n};\n\nSearchReference.prototype.fromObject = function (obj) {\n  if (typeof (obj) !== 'object')\n    throw new TypeError('object required');\n\n  this.uris = obj.uris ? obj.uris.slice() : [];\n\n  return true;\n};\n\nSearchReference.prototype._json = function (j) {\n  assert.ok(j);\n  j.uris = this.uris.slice();\n  return j;\n};\n\nSearchReference.prototype._parse = function (ber, length) {\n  assert.ok(ber);\n\n  while (ber.offset < length) {\n    var _url = ber.readString();\n    parseURL(_url);\n    this.uris.push(_url);\n  }\n\n  return true;\n};\n\nSearchReference.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  this.uris.forEach(function (u) {\n    ber.writeString(u.href || u);\n  });\n\n  return ber;\n};\n\n\n///--- Exports\n\nmodule.exports = SearchReference;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/url.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar querystring = require('querystring');\nvar url = require('url');\nvar util = require('util');\n\nvar dn = require('./dn');\nvar filter = require('./filters/index');\n\n\nmodule.exports = {\n\n  parse: function (urlStr, parseDN) {\n    var u = url.parse(urlStr);\n    if (!u.protocol || !(u.protocol === 'ldap:' || u.protocol === 'ldaps:'))\n      throw new TypeError(urlStr + ' is an invalid LDAP url (protocol)');\n\n    u.secure = (u.protocol === 'ldaps:');\n\n    if (!u.hostname)\n      u.hostname = 'localhost';\n\n    if (!u.port) {\n      u.port = (u.secure ? 636 : 389);\n    } else {\n      u.port = parseInt(u.port, 10);\n    }\n\n    if (u.pathname) {\n      u.pathname = querystring.unescape(u.pathname.substr(1));\n      u.DN = parseDN ? dn.parse(u.pathname) : u.pathname;\n    }\n\n    if (u.search) {\n      u.attributes = [];\n      var tmp = u.search.substr(1).split('?');\n      if (tmp && tmp.length) {\n        if (tmp[0]) {\n          tmp[0].split(',').forEach(function (a) {\n            u.attributes.push(querystring.unescape(a.trim()));\n          });\n        }\n      }\n      if (tmp[1]) {\n        if (tmp[1] !== 'base' && tmp[1] !== 'one' && tmp[1] !== 'sub')\n          throw new TypeError(urlStr + ' is an invalid LDAP url (scope)');\n        u.scope = tmp[1];\n      }\n      if (tmp[2]) {\n        u.filter = querystring.unescape(tmp[2]);\n      }\n      if (tmp[3]) {\n        u.extensions = querystring.unescape(tmp[3]);\n      }\n\n      if (!u.scope)\n        u.scope = 'base';\n      if (!u.filter)\n        u.filter = filter.parseString('(objectclass=*)');\n      else\n        u.filter = filter.parseString(u.filter);\n    }\n\n    return u;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/search_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPResult = require('./result');\nvar SearchEntry = require('./search_entry');\nvar SearchReference = require('./search_reference');\n\nvar dtrace = require('../dtrace');\nvar parseDN = require('../dn').parse;\nvar parseURL = require('../url').parse;\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction SearchResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REP_SEARCH;\n  LDAPResult.call(this, options);\n\n  this.attributes = options.attributes ? options.attributes.slice() : [];\n  this.notAttributes = [];\n  this.sentEntries = 0;\n}\nutil.inherits(SearchResponse, LDAPResult);\n\n/**\n * Allows you to send a SearchEntry back to the client.\n *\n * @param {Object} entry an instance of SearchEntry.\n * @param {Boolean} nofiltering skip filtering notAttributes and '_' attributes.\n *                  Defaults to 'false'.\n */\nSearchResponse.prototype.send = function (entry, nofiltering) {\n  if (!entry || typeof (entry) !== 'object')\n    throw new TypeError('entry (SearchEntry) required');\n  if (nofiltering === undefined)\n    nofiltering = false;\n  if (typeof (nofiltering) !== 'boolean')\n    throw new TypeError('noFiltering must be a boolean');\n\n  var self = this;\n\n  if (entry instanceof SearchEntry || entry instanceof SearchReference) {\n    if (!entry.messageID)\n      entry.messageID = this.messageID;\n    if (entry.messageID !== this.messageID)\n      throw new Error('SearchEntry messageID mismatch');\n  } else {\n    if (!entry.attributes)\n      throw new Error('entry.attributes required');\n\n    var savedAttrs = {};\n    var all = (self.attributes.indexOf('*') !== -1);\n    Object.keys(entry.attributes).forEach(function (a) {\n      var _a = a.toLowerCase();\n      if (!nofiltering && _a.length && _a[0] === '_') {\n        savedAttrs[a] = entry.attributes[a];\n        delete entry.attributes[a];\n      } else if (!nofiltering && self.notAttributes.indexOf(_a) !== -1) {\n        savedAttrs[a] = entry.attributes[a];\n        delete entry.attributes[a];\n      } else if (all) {\n        return;\n      } else if (self.attributes.length && self.attributes.indexOf(_a) === -1) {\n        savedAttrs[a] = entry.attributes[a];\n        delete entry.attributes[a];\n      }\n    });\n\n    var save = entry;\n    entry = new SearchEntry({\n      objectName: typeof (save.dn) === 'string' ? parseDN(save.dn) : save.dn,\n      messageID: self.messageID,\n      log: self.log\n    });\n    entry.fromObject(save);\n  }\n\n  try {\n    if (this.log.debug())\n      this.log.debug('%s: sending:  %j', this.connection.ldap.id, entry.json);\n\n    this.connection.write(entry.toBer());\n    this.sentEntries++;\n\n    if (self._dtraceOp && self._dtraceId) {\n      dtrace.fire('server-search-entry', function () {\n        var c = self.connection || {ldap: {}};\n        return [\n          self._dtraceId || 0,\n          (c.remoteAddress || ''),\n          c.ldap.bindDN ? c.ldap.bindDN.toString() : '',\n          (self.requestDN ? self.requestDN.toString() : ''),\n          entry.objectName.toString(),\n          entry.attributes.length\n        ];\n      });\n    }\n\n    // Restore attributes\n    Object.keys(savedAttrs || {}).forEach(function (k) {\n      save.attributes[k] = savedAttrs[k];\n    });\n\n  } catch (e) {\n    this.log.warn(e, '%s failure to write message %j',\n                  this.connection.ldap.id, this.json);\n  }\n};\n\nSearchResponse.prototype.createSearchEntry = function (object) {\n  assert.object(object);\n\n  var entry = new SearchEntry({\n    messageID: this.messageID,\n    log: this.log,\n    objectName: object.objectName || object.dn\n  });\n  entry.fromObject((object.attributes || object));\n  return entry;\n};\n\nSearchResponse.prototype.createSearchReference = function (uris) {\n  if (!uris)\n    throw new TypeError('uris ([string]) required');\n\n  if (!Array.isArray(uris))\n    uris = [uris];\n\n  for (var i = 0; i < uris.length; i++) {\n    if (typeof (uris[i]) == 'string')\n      uris[i] = parseURL(uris[i]);\n  }\n\n  var self = this;\n  return new SearchReference({\n    messageID: self.messageID,\n    log: self.log,\n    uris: uris\n  });\n};\n\n\n///--- Exports\n\nmodule.exports = SearchResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/unbind_request.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./message');\nvar dn = require('../dn');\nvar Protocol = require('../protocol');\n\n\n///--- Globals\n\nvar DN = dn.DN;\nvar RDN = dn.RDN;\n\n\n///--- API\n\nfunction UnbindRequest(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = Protocol.LDAP_REQ_UNBIND;\n  LDAPMessage.call(this, options);\n}\nutil.inherits(UnbindRequest, LDAPMessage);\nObject.defineProperties(UnbindRequest.prototype, {\n  type: {\n    get: function getType() { return 'UnbindRequest'; },\n    configurable: false\n  },\n  _dn: {\n    get: function getDN() {\n      if (this.connection) {\n        return this.connection.ldap.bindDN;\n      } else {\n        return new DN([new RDN({cn: 'anonymous'})]);\n      }\n    },\n    configurable: false\n  }\n});\n\nUnbindRequest.prototype._parse = function (ber) {\n  assert.ok(ber);\n\n  return true;\n};\n\nUnbindRequest.prototype._toBer = function (ber) {\n  assert.ok(ber);\n\n  return ber;\n};\n\nUnbindRequest.prototype._json = function (j) {\n  assert.ok(j);\n\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = UnbindRequest;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/unbind_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar dtrace = require('../dtrace');\n\nvar LDAPMessage = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n// Ok, so there's really no such thing as an unbind 'response', but to make\n// the framework not suck, I just made this up, and have it stubbed so it's\n// not such a one-off.\n\nfunction UnbindResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = 0;\n  LDAPMessage.call(this, options);\n}\nutil.inherits(UnbindResponse, LDAPMessage);\nObject.defineProperties(UnbindResponse.prototype, {\n  type: {\n    get: function getType() { return 'UnbindResponse'; },\n    configurable: false\n  }\n});\n\n/**\n * Special override that just ends the connection, if present.\n *\n * @param {Number} status completely ignored.\n */\nUnbindResponse.prototype.end = function (status) {\n  assert.ok(this.connection);\n\n  this.log.trace('%s: unbinding!', this.connection.ldap.id);\n\n  this.connection.end();\n\n  var self = this;\n  if (self._dtraceOp && self._dtraceId) {\n    dtrace.fire('server-' + self._dtraceOp + '-done', function () {\n      var c = self.connection || {ldap: {}};\n      return [\n        self._dtraceId || 0,\n        (c.remoteAddress || ''),\n        c.ldap.bindDN ? c.ldap.bindDN.toString() : '',\n        (self.requestDN ? self.requestDN.toString() : ''),\n        0,\n        ''\n      ];\n    });\n  }\n};\n\nUnbindResponse.prototype._json = function (j) {\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = UnbindResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/messages/abandon_response.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\nvar LDAPMessage = require('./result');\nvar Protocol = require('../protocol');\n\n\n///--- API\n\nfunction AbandonResponse(options) {\n  options = options || {};\n  assert.object(options);\n\n  options.protocolOp = 0;\n  LDAPMessage.call(this, options);\n}\nutil.inherits(AbandonResponse, LDAPMessage);\nObject.defineProperties(AbandonResponse.prototype, {\n  type: {\n    get: function getType() { return 'AbandonResponse'; },\n    configurable: false\n  }\n});\n\nAbandonResponse.prototype.end = function (status) {};\n\nAbandonResponse.prototype._json = function (j) {\n  return j;\n};\n\n\n///--- Exports\n\nmodule.exports = AbandonResponse;\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/errors/index.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar util = require('util');\nvar assert = require('assert-plus');\n\nvar LDAPResult = require('../messages').LDAPResult;\n\n\n///--- Globals\n\nvar CODES = require('./codes');\nvar ERRORS = [];\n\n\n///--- Error Base class\n\nfunction LDAPError(message, dn, caller) {\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, caller || LDAPError);\n\n  this.lde_message = message;\n  this.lde_dn = dn;\n}\nutil.inherits(LDAPError, Error);\nObject.defineProperties(LDAPError.prototype, {\n  name: {\n    get: function getName() { return 'LDAPError'; },\n    configurable: false\n  },\n  code: {\n    get: function getCode() { return CODES.LDAP_OTHER; },\n    configurable: false\n  },\n  message: {\n    get: function getMessage() {\n      return this.lde_message || this.name;\n    },\n    configurable: false\n  },\n  dn: {\n    get: function getDN() {\n      return (this.lde_dn ? this.lde_dn.toString() : '');\n    },\n    configurable: false\n  }\n});\n\n\n///--- Exported API\n\nmodule.exports = {};\nmodule.exports.LDAPError = LDAPError;\n\n// Some whacky games here to make sure all the codes are exported\nObject.keys(CODES).forEach(function (code) {\n  module.exports[code] = CODES[code];\n  if (code === 'LDAP_SUCCESS')\n    return;\n\n  var err = '';\n  var msg = '';\n  var pieces = code.split('_').slice(1);\n  for (var i = 0; i < pieces.length; i++) {\n    var lc = pieces[i].toLowerCase();\n    var key = lc.charAt(0).toUpperCase() + lc.slice(1);\n    err += key;\n    msg += key + ((i + 1) < pieces.length ? ' ' : '');\n  }\n\n  if (!/\\w+Error$/.test(err))\n    err += 'Error';\n\n  // At this point LDAP_OPERATIONS_ERROR is now OperationsError in $err\n  // and 'Operations Error' in $msg\n  module.exports[err] = function (message, dn, caller) {\n    LDAPError.call(this, message, dn, caller || module.exports[err]);\n  };\n  module.exports[err].constructor = module.exports[err];\n  util.inherits(module.exports[err], LDAPError);\n  Object.defineProperties(module.exports[err].prototype, {\n    name: {\n      get: function getName() { return err; },\n      configurable: false\n    },\n    code: {\n      get: function getCode() { return CODES[code]; },\n      configurable: false\n    }\n  });\n\n  ERRORS[CODES[code]] = {\n    err: err,\n    message: msg\n  };\n});\n\nmodule.exports.getError = function (res) {\n  assert.ok(res instanceof LDAPResult, 'res (LDAPResult) required');\n\n  var errObj = ERRORS[res.status];\n  var E = module.exports[errObj.err];\n  return new E(res.errorMessage || errObj.message,\n               res.matchedDN || null,\n               module.exports.getError);\n};\n\nmodule.exports.getMessage = function (code) {\n  assert.number(code, 'code (number) required');\n\n  var errObj = ERRORS[code];\n  return (errObj && errObj.message ? errObj.message : '');\n};\n\n\n///--- Custom application errors\n\nfunction ConnectionError(message) {\n  LDAPError.call(this, message, null, ConnectionError);\n}\nutil.inherits(ConnectionError, LDAPError);\nmodule.exports.ConnectionError = ConnectionError;\nObject.defineProperties(ConnectionError.prototype, {\n  name: {\n    get: function () { return 'ConnectionError'; },\n    configurable: false\n  }\n});\n\nfunction AbandonedError(message) {\n  LDAPError.call(this, message, null, AbandonedError);\n}\nutil.inherits(AbandonedError, LDAPError);\nmodule.exports.AbandonedError = AbandonedError;\nObject.defineProperties(AbandonedError.prototype, {\n  name: {\n    get: function () { return 'AbandonedError'; },\n    configurable: false\n  }\n});\n\nfunction TimeoutError(message) {\n  LDAPError.call(this, message, null, TimeoutError);\n}\nutil.inherits(TimeoutError, LDAPError);\nmodule.exports.TimeoutError = TimeoutError;\nObject.defineProperties(TimeoutError.prototype, {\n  name: {\n    get: function () { return 'TimeoutError'; },\n    configurable: false\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/server.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar EventEmitter = require('events').EventEmitter;\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\n\nvar asn1 = require('asn1');\nvar VError = require('verror').VError;\n\nvar dn = require('./dn');\nvar dtrace = require('./dtrace');\nvar errors = require('./errors');\nvar Protocol = require('./protocol');\n\nvar Parser = require('./messages').Parser;\nvar AbandonResponse = require('./messages/abandon_response');\nvar AddResponse = require('./messages/add_response');\nvar BindResponse = require('./messages/bind_response');\nvar CompareResponse = require('./messages/compare_response');\nvar DeleteResponse = require('./messages/del_response');\nvar ExtendedResponse = require('./messages/ext_response');\nvar LDAPResult = require('./messages/result');\nvar ModifyResponse = require('./messages/modify_response');\nvar ModifyDNResponse = require('./messages/moddn_response');\nvar SearchRequest = require('./messages/search_request');\nvar SearchResponse = require('./messages/search_response');\nvar UnbindResponse = require('./messages/unbind_response');\n\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\nvar BerReader = asn1.BerReader;\nvar DN = dn.DN;\n\nvar sprintf = util.format;\n\n\n///--- Helpers\n\nfunction mergeFunctionArgs(argv, start, end) {\n  assert.ok(argv);\n\n  if (!start)\n    start = 0;\n  if (!end)\n    end = argv.length;\n\n  var handlers = [];\n\n  for (var i = start; i < end; i++) {\n    if (argv[i] instanceof Array) {\n      var arr = argv[i];\n      for (var j = 0; j < arr.length; j++) {\n        if (!(arr[j] instanceof Function)) {\n          throw new TypeError('Invalid argument type: ' + typeof (arr[j]));\n        }\n        handlers.push(arr[j]);\n      }\n    } else if (argv[i] instanceof Function) {\n      handlers.push(argv[i]);\n    } else {\n      throw new TypeError('Invalid argument type: ' + typeof (argv[i]));\n    }\n  }\n\n  return handlers;\n}\n\n\nfunction getResponse(req) {\n  assert.ok(req);\n\n  var Response;\n\n  switch (req.protocolOp) {\n  case Protocol.LDAP_REQ_BIND:\n    Response = BindResponse;\n    break;\n  case Protocol.LDAP_REQ_ABANDON:\n    Response = AbandonResponse;\n    break;\n  case Protocol.LDAP_REQ_ADD:\n    Response = AddResponse;\n    break;\n  case Protocol.LDAP_REQ_COMPARE:\n    Response = CompareResponse;\n    break;\n  case Protocol.LDAP_REQ_DELETE:\n    Response = DeleteResponse;\n    break;\n  case Protocol.LDAP_REQ_EXTENSION:\n    Response = ExtendedResponse;\n    break;\n  case Protocol.LDAP_REQ_MODIFY:\n    Response = ModifyResponse;\n    break;\n  case Protocol.LDAP_REQ_MODRDN:\n    Response = ModifyDNResponse;\n    break;\n  case Protocol.LDAP_REQ_SEARCH:\n    Response = SearchResponse;\n    break;\n  case Protocol.LDAP_REQ_UNBIND:\n    Response = UnbindResponse;\n    break;\n  default:\n    return null;\n  }\n  assert.ok(Response);\n\n  var res = new Response({\n    messageID: req.messageID,\n    log: req.log,\n    attributes: ((req instanceof SearchRequest) ? req.attributes : undefined)\n  });\n  res.connection = req.connection;\n  res.logId = req.logId;\n\n  return res;\n}\n\n\nfunction defaultHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.matchedDN = req.dn.toString();\n  res.errorMessage = 'Server method not implemented';\n  res.end(errors.LDAP_OTHER);\n  return next();\n}\n\n\nfunction defaultNoOpHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.end();\n  return next();\n}\n\n\nfunction noSuffixHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.errorMessage = 'No tree found for: ' + req.dn.toString();\n  res.end(errors.LDAP_NO_SUCH_OBJECT);\n  return next();\n}\n\n\nfunction noExOpHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.errorMessage = req.requestName + ' not supported';\n  res.end(errors.LDAP_PROTOCOL_ERROR);\n  return next();\n}\n\n\nfunction fireDTraceProbe(req, res) {\n  assert.ok(req);\n\n  req._dtraceId = res._dtraceId = dtrace._nextId();\n  var probeArgs = [\n    req._dtraceId,\n    req.connection.remoteAddress || 'localhost',\n    req.connection.ldap.bindDN.toString(),\n    req.dn.toString()\n  ];\n\n  var op;\n  switch (req.protocolOp) {\n  case Protocol.LDAP_REQ_ABANDON:\n    op = 'abandon';\n    break;\n  case Protocol.LDAP_REQ_ADD:\n    op = 'add';\n    probeArgs.push(req.attributes.length);\n    break;\n  case Protocol.LDAP_REQ_BIND:\n    op = 'bind';\n    break;\n  case Protocol.LDAP_REQ_COMPARE:\n    op = 'compare';\n    probeArgs.push(req.attribute);\n    probeArgs.push(req.value);\n    break;\n  case Protocol.LDAP_REQ_DELETE:\n    op = 'delete';\n    break;\n  case Protocol.LDAP_REQ_EXTENSION:\n    op = 'exop';\n    probeArgs.push(req.name);\n    probeArgs.push(req.value);\n    break;\n  case Protocol.LDAP_REQ_MODIFY:\n    op = 'modify';\n    probeArgs.push(req.changes.length);\n    break;\n  case Protocol.LDAP_REQ_MODRDN:\n    op = 'modifydn';\n    probeArgs.push(req.newRdn.toString());\n    probeArgs.push((req.newSuperior ? req.newSuperior.toString() : ''));\n    break;\n  case Protocol.LDAP_REQ_SEARCH:\n    op = 'search';\n    probeArgs.push(req.scope);\n    probeArgs.push(req.filter.toString());\n    break;\n  case Protocol.LDAP_REQ_UNBIND:\n    op = 'unbind';\n    break;\n  default:\n    break;\n  }\n\n  res._dtraceOp = op;\n  dtrace.fire('server-' + op + '-start', function () {\n    return probeArgs;\n  });\n}\n\n\n\n///--- API\n\n/**\n * Constructs a new server that you can call .listen() on, in the various\n * forms node supports.  You need to first assign some handlers to the various\n * LDAP operations however.\n *\n * The options object currently only takes a certificate/private key, and a\n * bunyan logger handle.\n *\n * This object exposes the following events:\n *  - 'error'\n *  - 'close'\n *\n * @param {Object} options (optional) parameterization object.\n * @throws {TypeError} on bad input.\n */\nfunction Server(options) {\n  if (options) {\n    if (typeof (options) !== 'object')\n      throw new TypeError('options (object) required');\n    if (typeof (options.log) !== 'object')\n      throw new TypeError('options.log must be an object');\n\n    if (options.certificate || options.key) {\n      if (!(options.certificate && options.key) ||\n          (typeof (options.certificate) !== 'string' &&\n          !Buffer.isBuffer(options.certificate)) ||\n          (typeof (options.key) !== 'string' &&\n          !Buffer.isBuffer(options.key))) {\n        throw new TypeError('options.certificate and options.key ' +\n                            '(string or buffer) are both required for TLS');\n      }\n    }\n  } else {\n    options = {};\n  }\n  var self = this;\n\n  EventEmitter.call(this, options);\n\n  this._chain = [];\n  this.log = options.log;\n  this.strictDN = (options.strictDN !== undefined) ? options.strictDN : true;\n\n  var log = this.log;\n\n  function setupConnection(c) {\n    assert.ok(c);\n\n    if (c.type === 'unix') {\n      c.remoteAddress = self.server.path;\n      c.remotePort = c.fd;\n    } else if (c.socket) {\n      // TLS\n      c.remoteAddress = c.socket.remoteAddress;\n      c.remotePort = c.socket.remotePort;\n    }\n\n\n    var rdn = new dn.RDN({cn: 'anonymous'});\n\n    c.ldap = {\n      id: c.remoteAddress + ':' + c.remotePort,\n      config: options,\n      _bindDN: new DN([rdn])\n    };\n    c.addListener('timeout', function () {\n      log.trace('%s timed out', c.ldap.id);\n      c.destroy();\n    });\n    c.addListener('end', function () {\n      log.trace('%s shutdown', c.ldap.id);\n    });\n    c.addListener('error', function (err) {\n      log.warn('%s unexpected connection error', c.ldap.id, err);\n      self.emit('clientError', err);\n      c.destroy();\n    });\n    c.addListener('close', function (had_err) {\n      log.trace('%s close; had_err=%j', c.ldap.id, had_err);\n      c.end();\n    });\n\n    c.ldap.__defineGetter__('bindDN', function () {\n      return c.ldap._bindDN;\n    });\n    c.ldap.__defineSetter__('bindDN', function (val) {\n      if (!(val instanceof DN))\n        throw new TypeError('DN required');\n\n      c.ldap._bindDN = val;\n      return val;\n    });\n    return c;\n  }\n\n  function newConnection(c) {\n    setupConnection(c);\n    log.trace('new connection from %s', c.ldap.id);\n\n    dtrace.fire('server-connection', function () {\n      return [c.remoteAddress];\n    });\n\n    c.parser = new Parser({\n      log: options.log\n    });\n    c.parser.on('message', function (req) {\n      req.connection = c;\n      req.logId = c.ldap.id + '::' + req.messageID;\n      req.startTime = new Date().getTime();\n\n      if (log.debug())\n        log.debug('%s: message received: req=%j', c.ldap.id, req.json);\n\n      var res = getResponse(req);\n      if (!res) {\n        log.warn('Unimplemented server method: %s', req.type);\n        c.destroy();\n        return false;\n      }\n\n      // parse string DNs for routing/etc\n      try {\n        switch (req.protocolOp) {\n        case Protocol.LDAP_REQ_BIND:\n          req.name = dn.parse(req.name);\n          break;\n        case Protocol.LDAP_REQ_ADD:\n        case Protocol.LDAP_REQ_COMPARE:\n        case Protocol.LDAP_REQ_DELETE:\n          req.entry = dn.parse(req.entry);\n          break;\n        case Protocol.LDAP_REQ_MODIFY:\n          req.object = dn.parse(req.object);\n          break;\n        case Protocol.LDAP_REQ_MODRDN:\n          req.entry = dn.parse(req.entry);\n          // TODO: handle newRdn/Superior\n          break;\n        case Protocol.LDAP_REQ_SEARCH:\n          req.baseObject = dn.parse(req.baseObject);\n          break;\n        default:\n          break;\n        }\n      } catch (e) {\n        if (self.strictDN) {\n          return res.end(errors.LDAP_INVALID_DN_SYNTAX);\n        }\n      }\n\n      res.connection = c;\n      res.logId = req.logId;\n      res.requestDN = req.dn;\n\n      var chain = self._getHandlerChain(req, res);\n\n      var i = 0;\n      return function (err) {\n        function sendError(err) {\n          res.status = err.code || errors.LDAP_OPERATIONS_ERROR;\n          res.matchedDN = req.suffix ? req.suffix.toString() : '';\n          res.errorMessage = err.message || '';\n          return res.end();\n        }\n\n        function after() {\n          if (!self._postChain || !self._postChain.length)\n            return;\n\n          function next() {} // stub out next for the post chain\n\n          self._postChain.forEach(function (c) {\n            c.call(self, req, res, next);\n          });\n        }\n\n        if (err) {\n          log.trace('%s sending error: %s', req.logId, err.stack || err);\n          self.emit('clientError', err);\n          sendError(err);\n          return after();\n        }\n\n        try {\n          var next = arguments.callee;\n          if (chain.handlers[i])\n            return chain.handlers[i++].call(chain.backend, req, res, next);\n\n          if (req.protocolOp === Protocol.LDAP_REQ_BIND && res.status === 0)\n            c.ldap.bindDN = req.dn;\n\n          return after();\n        } catch (e) {\n          if (!e.stack)\n            e.stack = e.toString();\n          log.error('%s uncaught exception: %s', req.logId, e.stack);\n          return sendError(new errors.OperationsError(e.message));\n        }\n\n      }();\n    });\n\n    c.parser.on('error', function (err, message) {\n      self.emit('error', new VError(err, 'Parser error for %s', c.ldap.id));\n\n      if (!message)\n        return c.destroy();\n\n      var res = getResponse(message);\n      if (!res)\n        return c.destroy();\n\n      res.status = 0x02; // protocol error\n      res.errorMessage = err.toString();\n      return c.end(res.toBer());\n    });\n\n    c.on('data', function (data) {\n      if (log.trace())\n        log.trace('data on %s: %s', c.ldap.id, util.inspect(data));\n\n      c.parser.write(data);\n    });\n\n  } // end newConnection\n\n  this.routes = {};\n  if ((options.cert || options.certificate) && options.key) {\n    options.cert = options.cert || options.certificate;\n    this.server = tls.createServer(options, newConnection);\n  } else {\n    this.server = net.createServer(newConnection);\n  }\n  this.server.log = options.log;\n  this.server.ldap = {\n    config: options\n  };\n  this.server.on('close', function () {\n    self.emit('close');\n  });\n  this.server.on('error', function (err) {\n    self.emit('error', err);\n  });\n}\nutil.inherits(Server, EventEmitter);\nObject.defineProperties(Server.prototype, {\n  maxConnections: {\n    get: function getMaxConnections() {\n      return this.server.maxConnections;\n    },\n    set: function setMaxConnections(val) {\n      this.server.maxConnections = val;\n    },\n    configurable: false\n  },\n  connections: {\n    get: function getConnections() {\n      return this.server.connections;\n    },\n    configurable: false\n  },\n  name: {\n    get: function getName() {\n      return 'LDAPServer';\n    },\n    configurable: false\n  },\n  url: {\n    get: function getURL() {\n      var str;\n      var addr = this.server.address();\n      if (!addr) {\n        return null;\n      }\n      if (!addr.family) {\n        str = 'ldapi://';\n        str += this.host.replace(new RegExp('/', 'g'), '%2f');\n        return str;\n      }\n      if (this.server instanceof tls.Server) {\n        str = 'ldaps://';\n      } else {\n        str = 'ldap://';\n      }\n      str += this.host + ':' + this.port;\n      return str;\n    },\n    configurable: false\n  }\n});\nmodule.exports = Server;\n\n\n/**\n * Adds a handler (chain) for the LDAP add method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.add = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_ADD, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP bind method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.bind = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_BIND, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP compare method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.compare = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_COMPARE, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP delete method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.del = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_DELETE, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP exop method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name OID to assign this handler chain to.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input.\n */\nServer.prototype.exop = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_EXTENSION, name, args, true);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP modify method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.modify = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_MODIFY, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP modifyDN method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.modifyDN = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_MODRDN, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP search method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.search = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_SEARCH, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP unbind method.\n *\n * This method is different than the others and takes no mount point, as unbind\n * is a connection-wide operation, not constrianed to part of the DIT.\n *\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.unbind = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  return this._mount(Protocol.LDAP_REQ_UNBIND, 'unbind', args, true);\n};\n\n\nServer.prototype.use = function use() {\n  var args = Array.prototype.slice.call(arguments);\n  var chain = mergeFunctionArgs(args, 0, args.length);\n  var self = this;\n  chain.forEach(function (c) {\n    self._chain.push(c);\n  });\n};\n\n\nServer.prototype.after = function () {\n  if (!this._postChain)\n    this._postChain = [];\n\n  var self = this;\n  mergeFunctionArgs(arguments).forEach(function (h) {\n    self._postChain.push(h);\n  });\n};\n\n\n// All these just reexpose the requisite net.Server APIs\nServer.prototype.listen = function (port, host, callback) {\n  if (typeof (port) !== 'number' && typeof (port) !== 'string')\n    throw new TypeError('port (number or path) required');\n\n  if (typeof (host) === 'function') {\n    callback = host;\n    host = '0.0.0.0';\n  }\n  if (typeof (port) === 'string' && /^[0-9]+$/.test(port)) {\n    // Disambiguate between string ports and file paths\n    port = parseInt(port, 10);\n  }\n  var self = this;\n\n  function cbListen() {\n    if (typeof (port) === 'number') {\n      self.host = self.address().address;\n      self.port = self.address().port;\n    } else {\n      self.host = port;\n      self.port = self.server.fd;\n    }\n\n    if (typeof (callback) === 'function')\n      callback();\n  }\n\n  if (typeof (port) === 'number') {\n    return this.server.listen(port, host, cbListen);\n  } else {\n    return this.server.listen(port, cbListen);\n  }\n};\nServer.prototype.listenFD = function (fd) {\n  this.host = 'unix-domain-socket';\n  this.port = fd;\n  return this.server.listenFD(fd);\n};\nServer.prototype.close = function () {\n  return this.server.close();\n};\nServer.prototype.address = function () {\n  return this.server.address();\n};\n\n\nServer.prototype._getRoute = function (_dn, backend) {\n  assert.ok(dn);\n\n  if (!backend)\n    backend = this;\n\n  var name;\n  if (_dn instanceof dn.DN) {\n    name = _dn.toString();\n  } else {\n    name = _dn;\n  }\n\n  if (!this.routes[name]) {\n    this.routes[name] = {};\n    this.routes[name].backend = backend;\n    this.routes[name].dn = _dn;\n    // Force regeneration of the route key cache on next request\n    this._routeKeyCache = null;\n  }\n\n  return this.routes[name];\n};\n\n\nServer.prototype._sortedRouteKeys = function _sortedRouteKeys() {\n  // The filtered/sorted route keys are cached to prevent needlessly\n  // regenerating the list for every incoming request.\n  if (!this._routeKeyCache) {\n    var self = this;\n    var reversedRDNsToKeys = {};\n    // Generate mapping of reversedRDNs(DN) -> routeKey\n    Object.keys(this.routes).forEach(function (key) {\n      var _dn = self.routes[key].dn;\n      // Ignore non-DN routes such as exop or unbind\n      if (_dn instanceof dn.DN) {\n        var reversed = _dn.clone();\n        reversed.rdns.reverse();\n        reversedRDNsToKeys[reversed.format()] = key;\n      }\n    });\n    var output = [];\n    // Reverse-sort on reversedRDS(DN) in order to output routeKey list.\n    // This will place more specific DNs in front of their parents:\n    // 1. dc=test, dc=domain, dc=sub\n    // 2. dc=test, dc=domain\n    // 3. dc=other, dc=foobar\n    Object.keys(reversedRDNsToKeys).sort().reverse().forEach(function (_dn) {\n      output.push(reversedRDNsToKeys[_dn]);\n    });\n    this._routeKeyCache = output;\n  }\n  return this._routeKeyCache;\n};\n\n\nServer.prototype._getHandlerChain = function _getHandlerChain(req, res) {\n  assert.ok(req);\n\n  fireDTraceProbe(req, res);\n\n  // check anonymous bind\n  if (req.protocolOp === Protocol.LDAP_REQ_BIND &&\n      req.dn.toString() === '' &&\n      req.credentials === '') {\n    return {\n      backend: self,\n      handlers: [defaultNoOpHandler]\n    };\n  }\n\n  var op = '0x' + req.protocolOp.toString(16);\n  var self = this;\n  var routes = this.routes;\n  var route;\n\n  // Special cases are exops, unbinds and abandons. Handle those first.\n  if (req.protocolOp === Protocol.LDAP_REQ_EXTENSION) {\n    route = routes[req.requestName];\n    if (route) {\n      return {\n        backend: route.backend,\n        handlers: (route[op] ? route[op] : [noExOpHandler])\n      };\n    } else {\n      return {\n        backend: self,\n        handlers: [noExOpHandler]\n      };\n    }\n  } else if (req.protocolOp === Protocol.LDAP_REQ_UNBIND) {\n    route = routes['unbind'];\n    if (route) {\n      return {\n        backend: route.backend,\n        handlers: route[op]\n      };\n    } else {\n      return {\n        backend: self,\n        handlers: [defaultNoOpHandler]\n      };\n    }\n  } else if (req.protocolOp === Protocol.LDAP_REQ_ABANDON) {\n    return {\n      backend: self,\n      handlers: [defaultNoOpHandler]\n    };\n  }\n\n  // Otherwise, match via DN rules\n  assert.ok(req.dn);\n  var keys = this._sortedRouteKeys();\n  var fallbackHandler = [noSuffixHandler];\n  // invalid DNs in non-strict mode are routed to the default handler\n  var testDN = (typeof (req.dn) === 'string') ? '' : req.dn;\n\n  for (var i = 0; i < keys.length; i++) {\n    var suffix = keys[i];\n    route = routes[suffix];\n    assert.ok(route.dn);\n    // Match a valid route or the route wildcard ('')\n    if (route.dn.equals(testDN) || route.dn.parentOf(testDN) || suffix === '') {\n      if (route[op]) {\n        // We should be good to go.\n        req.suffix = route.dn;\n        return {\n          backend: route.backend,\n          handlers: route[op]\n        };\n      } else {\n        if (suffix === '') {\n          break;\n        } else {\n          // We found a valid suffix but not a valid operation.\n          // There might be a more generic suffix with a legitimate operation.\n          fallbackHandler = [defaultHandler];\n        }\n      }\n    }\n  }\n  return {\n    backend: self,\n    handlers: fallbackHandler\n  };\n};\n\n\nServer.prototype._mount = function (op, name, argv, notDN) {\n  assert.ok(op);\n  assert.ok(name !== undefined);\n  assert.ok(argv);\n\n  if (typeof (name) !== 'string')\n    throw new TypeError('name (string) required');\n  if (!argv.length)\n    throw new Error('at least one handler required');\n\n  var backend = this;\n  var index = 0;\n\n  if (typeof (argv[0]) === 'object' && !Array.isArray(argv[0])) {\n    backend = argv[0];\n    index = 1;\n  }\n  var route = this._getRoute(notDN ? name : dn.parse(name), backend);\n\n  var chain = this._chain.slice();\n  argv.slice(index).forEach(function (a) {\n    chain.push(a);\n  });\n  route['0x' + op.toString(16)] = mergeFunctionArgs(chain);\n\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/persistent_search.js":"///--- Globals\n\nvar parseDN = require('./dn').parse;\n\nvar EntryChangeNotificationControl =\n  require('./controls').EntryChangeNotificationControl;\n\n///--- API\n\n// Cache used to store connected persistent search clients\nfunction PersistentSearch() {\n  this.clientList = [];\n}\n\n\nPersistentSearch.prototype.addClient = function (req, res, callback) {\n  if (typeof (req) !== 'object')\n    throw new TypeError('req must be an object');\n  if (typeof (res) !== 'object')\n    throw new TypeError('res must be an object');\n  if (callback && typeof (callback) !== 'function')\n    throw new TypeError('callback must be a function');\n\n  var log = req.log;\n\n  var client = {};\n  client.req = req;\n  client.res = res;\n\n  log.debug('%s storing client', req.logId);\n\n  this.clientList.push(client);\n\n  log.debug('%s stored client', req.logId);\n  log.debug('%s total number of clients %s',\n            req.logId, this.clientList.length);\n  if (callback)\n    callback(client);\n};\n\n\nPersistentSearch.prototype.removeClient = function (req, res, callback) {\n  if (typeof (req) !== 'object')\n    throw new TypeError('req must be an object');\n  if (typeof (res) !== 'object')\n    throw new TypeError('res must be an object');\n  if (callback && typeof (callback) !== 'function')\n    throw new TypeError('callback must be a function');\n\n  var log = req.log;\n  log.debug('%s removing client', req.logId);\n  var client = {};\n  client.req = req;\n  client.res = res;\n\n  // remove the client if it exists\n  this.clientList.forEach(function (element, index, array) {\n    if (element.req === client.req) {\n      log.debug('%s removing client from list', req.logId);\n      array.splice(index, 1);\n    }\n  });\n\n  log.debug('%s number of persistent search clients %s',\n            req.logId, this.clientList.length);\n  if (callback)\n    callback(client);\n};\n\n\nfunction getOperationType(requestType) {\n  switch (requestType) {\n    case 'AddRequest':\n    case 'add':\n      return 1;\n    case 'DeleteRequest':\n    case 'delete':\n      return 2;\n    case 'ModifyRequest':\n    case 'modify':\n      return 4;\n    case 'ModifyDNRequest':\n    case 'modrdn':\n      return 8;\n    default:\n      throw new TypeError('requestType %s, is an invalid request type',\n                          requestType);\n  }\n}\n\n\nfunction getEntryChangeNotificationControl(req, obj, callback) {\n  // if we want to return a ECNC\n  if (req.persistentSearch.value.returnECs) {\n    var attrs = obj.attributes;\n    var value = {};\n    value.changeType = getOperationType(attrs.changetype);\n    // if it's a modDN request, fill in the previous DN\n    if (value.changeType === 8 && attrs.previousDN) {\n      value.previousDN = attrs.previousDN;\n    }\n\n    value.changeNumber = attrs.changenumber;\n    return new EntryChangeNotificationControl({ value: value });\n  } else {\n    return false;\n  }\n}\n\n\nfunction checkChangeType(req, requestType) {\n  return (req.persistentSearch.value.changeTypes &\n          getOperationType(requestType));\n}\n\n\n///--- Exports\n\nmodule.exports = {\n  PersistentSearchCache: PersistentSearch,\n  checkChangeType: checkChangeType,\n  getEntryChangeNotificationControl: getEntryChangeNotificationControl\n};\n","/home/travis/build/npmtest/node-npmtest-ldapjs/node_modules/ldapjs/lib/filters/escape.js":"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\n/**\n * RFC 2254 Escaping of filter strings\n *\n * Raw                     Escaped\n * (o=Parens (R Us))       (o=Parens \\28R Us\\29)\n * (cn=star*)              (cn=star\\2A)\n * (filename=C:\\MyFile)    (filename=C:\\5cMyFile)\n *\n * Use substr_filter to avoid having * ecsaped.\n *\n * @author [Austin King](https://github.com/ozten)\n */\nexports.escape = function (inp) {\n  if (typeof (inp) === 'string') {\n    var esc = '';\n    for (var i = 0; i < inp.length; i++) {\n      switch (inp[i]) {\n        case '*':\n          esc += '\\\\2a';\n          break;\n        case '(':\n          esc += '\\\\28';\n          break;\n        case ')':\n          esc += '\\\\29';\n          break;\n        case '\\\\':\n          esc += '\\\\5c';\n          break;\n        case '\\0':\n          esc += '\\\\00';\n          break;\n        default:\n          esc += inp[i];\n          break;\n      }\n    }\n    return esc;\n\n  } else {\n    return inp;\n  }\n};\n"}